# 2.进阶开发

[TOC]


<p id = "anther2.1"></p>
## **2.1WonderLLM**底层通信说明

### 2.1.1 语音大模型部署

>[!note]
>**注意：**
>
>* **WonderLLM模块具备“语音大模型TTS(语音合成)”功能，供开发者进阶扩展。本节主要对该功能进行介绍，并讲解语音大模型云端平台部署。**
>* **若用户暂无语音合成功能的使用需求，可跳过本节。**
>* **WonderMind模块支持“火山引擎”、“阿里云”两平台语音大模型调用，本教只程展示国际版“阿里云”语音大模型TTS（语音合成）功能。**



* #### 阿里云语音大模型部署

1. **注册账号** 

(1) 复制网址：[https://www.alibabacloud.com/](https://www.alibabacloud.com/)，打开通义大模型网页，点击右上角登录。

<img src="..\_static\media\chapter_2/section_1/media/image1.png" style="width:800px"  class="common_img" />

(2)接着点击右上角的**“注册按键”**。

<img src="..\_static\media\chapter_2/section_1/media/image33.png" style="width:800px"  class="common_img" />

(3)选择对应的注册类型 ，完成账号的注册（这里不做过多演示）。

<img src="..\_static\media\chapter_2/section_1/media/image34.png" style="width:800px"  class="common_img" />

(4)账号类型分为“**个人认证**”和“**企业认证**”，可根据实际情况选择对应的认证方式。

<img src="..\_static\media\chapter_2/section_1/media/image35.png" style="width:800px"  class="common_img" />

(4)根据提示词依次填写"**支付信息**"。

<img src="..\_static\media\chapter_2/section_1/media/image36.png" style="width:600px"  class="common_img" />

(5)选择绑定方式，并填写对应银行卡信息，绑定银行卡。

<img src="..\_static\media\chapter_2/section_1/media/image37.png" style="width:800px"  class="common_img" />



2. **在线大模型部署**

(1) 注册完成后，点击“**立即激活**”。

<img src="..\_static\media\chapter_2/section_1/media/image8.png" style="width:800px"  class="common_img" />

(2)  同意服务条款。

<img src="..\_static\media\chapter_2/section_1/media/image38.png" style="width:800px"  class="common_img" />

(3) 点击右上角的的设置按键，创建API-KEY。

<img src="..\_static\media\chapter_2/section_1/media/image10.png" style="width:800px"  class="common_img" />

(4) 点击右边的API-Key密钥管理，“**创建API-Key**“。

<img src="..\_static\media\chapter_2/section_1/media/image11.png" style="width:800px"  class="common_img" />

(5) 点击“**Create**”创建**API-Key**。

<img src="..\_static\media\chapter_2/section_1/media/image39.png" style="width:800px"  class="common_img" />

(6) **API KEY**为程序调用的密钥，点击查看后复制，后续调用该平台模型时需要使用，建议保存至本地备用。

<img src="..\_static\media\chapter_2/section_1/media/image16.png" style="width:800px"  class="common_img" />

(10) 至此，完成了大模型的创建及其部署。

  

### 2.1.2 I²C 通信协议与接口

* #### 概述

本文档描述了主控（MCU）与模块（I²C 从机地址 `0x55`）之间的通信协议与指令接口。
通信使用 ​**I²C 总线**​，速率 `400 kHz`，传输格式为 ​**JSON 文本**​，编码为 ​**UTF-8**​，并带有 ​**校验码**​。

该协议支持：

1. 发送控制指令​（如运动、执行动作、获取状态）

2. 接收机器人状态与传感器数据

3. 双向异步通信​，消息通过优先队列处理

4. 多线程安全的收发机制

5. 分片数据传输，支持大数据包传输

6. 语音合成功能，支持多种音色和TTS模型



* #### 硬件与总线参数

| 参数         | 值                                                           |
| ------------ | ------------------------------------------------------------ |
| 总线协议     | I²C                                                          |
| 工作模式     | 主机（MCU）与从机                                            |
| 从机地址     | `0x55`                                                       |
| 速率         | 400 kHz                                                      |
| 数据编码     | UTF-8 JSON                                                   |
| 最大数据长度 | 1024 字节（发送），1024 字节（接收） ，都是指实际接收或者发送的数据长度，包含帧头校验这些 |



* #### 内置指令与接口

1. 指令格式

所有指令均为 JSON 格式，统一结构如下：

```json
{
  "command": "指令名称",
  "params":  参数值（字符串 / 数字 / 列表）
}
```

2. 基础系统指令

| 指令名称        | 参数类型 | 说明                                             |
| --------------- | -------- | ------------------------------------------------ |
| `sleep`         | `"true"` | 让大模型模块进入待机/休眠状态                    |
| `abort`         | `"true"` | 中断大模型模块当前正在执行的操作                 |
| `vision`        | `string` | 视觉识别任务描述（自然语言）                     |
| `tts`           | `string` | 文本转语音，将文本转换为语音输出                 |
| `tts_model`     | `string` | 设置TTS模型，支持"aliyun"和"volcengine"          |
| `voice`         | `string` | 设置音色，使用音色名称作为参数                   |
| `status`        | `list`   | 返回状态数据（二维数组）                         |
| `action_finish` | `"true"` | 通知大模型动作已完成                             |
| `mcp_setting`   | `"true"` | MCP 配置完成确认                                 |
| `app_id`        | `string` | 设置应用ID，用于TTS服务认证                      |
| `access_token`  | `string` | 设置访问令牌，用于TTS服务认证(仅火山TTS服务需要) |

3. 状态码列表

(1) WonderLLM在上电工作后，会根据程序调度处于不同的工作状态，该工作状态可以被主机从IIC总线读取以配合主机执行一些自定义操作，用户使用时最常见的工作状态有：**①"idle"(模块休眠待唤醒)  ②"listening"(模块唤醒，正在侦听用户发言)  ③"speaking"(模块唤醒，正在播报回复)**。

(2) 系统定义了以下状态码：

| 状态码 | 状态名称        | 说明       |
| ------ | --------------- | ---------- |
| 0      | `unknown`       | 未知状态   |
| 1      | `starting`      | 启动中     |
| 2      | `configuring`   | 配置中     |
| 3      | `idle`          | 空闲       |
| 4      | `connecting`    | 连接中     |
| 5      | `listening`     | 监听中     |
| 6      | `speaking`      | 语音播报中 |
| 7      | `upgrading`     | 升级中     |
| 8      | `activating`    | 激活中     |
| 9      | `audio_testing` | 音频测试中 |
| 10     | `fatal_error`   | 致命错误   |
| 11     | `invalid_state` | 无效状态   |

4. 音色列表

系统支持以下音色(仅列举了部分音色)：

| 音色名称   | 音色ID                                        | 支持平台 | 语言支持   |
| ---------- | --------------------------------------------- | -------- | ---------- |
| `中英女`   | `zh_female_shuangkuaisisi_emo_v2_mars_bigtts` | 火山引擎 | 中文、英文 |
| `广西远舟` | `zh_male_guangxiyuanzhou_moon_bigtts`         | 火山引擎 | 中文       |
| `撒娇学妹` | `zh_female_yuanqinvyou_moon_bigtts`           | 火山引擎 | 中文       |
| `韩语女`   | `loongkyong_v2`                               | 阿里云   | 韩语       |
| `日语女`   | `loongtomoka_v2`                              | 阿里云   | 日语       |
| `粤英女`   | `longjiayi_v2`                                | 阿里云   | 粤语、英文 |



5. 使用示例

(1) 视觉识别

>[!note]
>**模块完成配网前(白色滚动条消失出现表情界面)，该功能无效**

```json
{
    "command": "vision",
    "params": "识别画面中有没有人，有就返回true，否则返回false，你的返回只能是true或者false， 不要任何解释和说明",
}
```

`params`：你要大模型进行的视觉任务，描述要清晰，有返回时会以**{"vision": "text"}**格式返回



(2) 语音合成

```json
{
    "command": "tts",
    "params": "你好，有什么可以帮到你的?",
}
```

`params`：要转换为语音的文本内容



(3) TTS模型设置

```json
{
    "command": "tts_model",
    "params": "aliyun", // 或 "volcengine"
}
```

`params`：TTS模型名称，支持"**aliyun**"和"**volcengine**"， 不能同时使用



(4) 音色设置

```json
{
    "command": "voice",
    "params": "中英女",
}
```

① `params`：音色名称，使用音色列表中的名称

② 火山详细音色列表参考：[火山引擎音色列表](https://www.volcengine.com/docs/6561/1257544)

③ 阿里详细音色列表参考 (cosyvoice-v2)：[阿里云音色列表](https://help.aliyun.com/zh/model-studio/cosyvoice-python-sdk?spm=a2c4g.11186623.0.0.16eb575eYDAV7s#dc692b9b51p27)



* #### **MCP工具简介**

1. **MCP（Model Context Protocol）** 是一个**开放协议**，允许AI模型（如小智AI）与外部工具、数据源和服务进行安全、标准化的交互。它能让AI能够突破自身知识库的限制，实时与外界交互。

2. 具体来说，MCP工具由用户自定义，包括定义该工具的：**①使用场景(大模型什么时候可以调用它)**  **②工具名称**  **③参数(调用该工具时，大模型、用户双方的返回内容)**等等，并向大模型注册。相当于将一些主机可实现的功能的调用接口开放给大模型。

3. 例如，WonderLLM搭配小车主控使用，我们可以将小车主控可以完成的如查询电量、控制运动、开关车灯等功能以MCP工具注册至小智AI平台大模型。在人机交互中，当用户下达了相关指令，大模型理解后会自动匹配已注册的MCP工具。若匹配成功，则以该MCP工具指定格式的字符串回传。模块同步将其从IIC总线转发至小车主控，小车主控在收到对应指令后即可完成相应功能。

4. 在WonderLLM中，所有MCP指令均为 **JSON** 格式传输。

   

* #### MCP 工具接口

1. 用户如需在大模型中注册自定义的MCP工具，需要在模块正式联网前，将其工具接口按照指定的**JSON字符串格式**进行编排并发送至WonderLLM模块，模块联网成功后，会将收取到的MCP工具接口字符串统一上传至大模型平台完成注册。

>[!note]
>**WonderLLM模块上电后:**
>
>* **需要在模块白色滚动条加载完成前，即配网工作完成前，将MCP工具接口以json格式发往模块完成注册，联网完成后向模块注册的MCP指令无效**
>* **WonderLLM上电后，内部也需要一定时间进行配置，不建议上电后立刻发送，可能导致注册失败，系统整体上电后1-2s后再发送即可**



2. MCP工具接口JSON字符串具体格式如下：

```json
{
    "tool_name": string,
    "command": string,
    "params": list,
    "block": bool,
    "return": bool
}
```

(1) `tool_name`：工具名称，保持格式**self**开头后面命名应该跟这个工具的功能相关

(2) `command`：调用**mcp**的工具描述，需要清晰明了,说明这个工具是干嘛的，大模型会根据这个工具的描述来判断是否需要调用

(3) `params`：当对话触发调用**mcp**时会返回**params**格式数据回来，**params**是列表，其中**int**表示数据类型，有**int, string, bool**三种类型，当为**int**时可以指定范围，如**-20**到**20**

(4) `block`：是否要让大模型等动作完成再继续, 执行完需调用 **action_finish** 通知完成,注意当**return**为**true**时，**block**设置不生效，因为**return**本身就是阻塞的

(5) `return`：一般有数据返回给大模型时才需要设为**true**，如传感器
>[!note]
>**所有参数加起来的长度不能超过1024，超过的部分会被截断，所有设置完成后需要调用基础系统指令mcp_setting告诉大模型已经完成mcp设置**



3. 示例1：动作执行

```json
{
    "tool_name": "self.robot.run_action",
    "command": "你要做动作时调用这个工具。可选动作有:'sit_dowm':坐下, 'go_prone':趴下，'stand': 立正",
    "params": [["run_action", "string"]],
    "block": "true",
    "return": "false"
}
```



4. 示例2：运动控制

```json
{
    "tool_name": "self.robot.move",
    "command": "你要移动时调用这个工具。可以控制前进后退，左转右转，前进步幅默认20, 后退步幅默认-20, 单位mm，左转步幅默认20, 右转步幅默认-20, 单位度，停止速度就都是0, 移动时的持续时间，单位毫秒",
    "params": [["go", "int", "-20", "20"], ["turn", "int", "-20", "20"], ["duration", "int"]],
    "block": "true",
    "return": "false"
}
```



5. 示例3：状态查询

```json
{
    "tool_name": "self.robot.get_status",
    "command": "你要获取机器人实时状态或者传感器数据时调用这个工具。包括battery，pose, touch_sensor, light_sensor等, 站着时姿态趋近0,坐着时姿态趋近-90",
    "params": [["get_status", "string"]],
    "block": "true",
    "return": "true"
}
```

(1) `params`：调用mcp时会触发大模型返回**params**格式数据回来，其中**string**会由大模型给出，由你跟大模型的对话决定，例如你要求获取当前姿态，那么他就可能返回的是**["get_status", "pose"]**，注意**command**里要描述清楚有哪些返回的选项

(2) `return`：当为**true**时，你需要返回**status**格式的数据给他，他是一个列表，如**{ "command": "status", "params":  [["pose", "0"], ["battery", 8000]] }**大模型接收到后会进行判断或者播报



* #### 主机向WonderLLM发送数据

在主机向WonderLLM传递数据时，无特定格式要求，只需将数据以JSON格式构造成字符串，按UTF-8格式编码后发出即可。

1. 发送内容说明

在人机交互过程中，主机向WonderLLM传递的数据主要为以下两种类型信息：

**(1) MCP工具接口**  

**(2) 基础系统指令**



* #### 主机从WonderLLM读取数据

1. 分片传输机制

当向主机发送的数据包较大时，模块会自动进行分片传输：

(1) **单分片数据**：分片ID等于1，总分片数等于1

(2) **多分片数据**：分片ID从1开始递增，**TOTAL_FRAGMENTS**为总分片数

(3) **分片组标识**：每个分片数据包包含**group_id**，使用毫秒级时间戳区分不同的数据组

(4) **分片重组**：接收端会根据分片ID和group_id自动重组数据

(5) **超时处理**：分片传输超时时间为 2 秒，超时后会清空分片缓存



2. 帧格式

在WonderLLM向主机传递数据时，会将数据分片处理并依次发送，每一片数据由两部分组成：**“帧头”**、**“数据+校验位”**。

>[!note]
>
>* **主机在接收完“帧头”、“数据+校验位”部分，均需产生停止位，后续数据才能正常发送**
>* **整体模块数据读取流程如下：接收第1片8字节“帧头”(产生停止位)--接收第1片“数据+校验位”(产生停止位)--...--接收最后1片8字节“帧头”(产生停止位)--接收最后1片“数据+校验位”((产生停止位)**



3. 帧头

<table>
<tr><td>字段</td><td>长度（字节）</td><td>说明</td></tr>
<tr><td>FLAG1</td><td>1</td><td>0xAA，固定值</td></tr>
<tr><td>FLAG2</td><td>1</td><td>0x55，固定值</td></tr>
<tr><td>LEN_H</td><td>1</td><td>数据区长度高字节（不含校验字节）</td></tr>
<tr><td>LEN_L</td><td>1</td><td>数据区长度低字节（不含校验字节）</td></tr>
<tr><td>PART_ID_L</td><td>1</td><td>分片ID低8位</td></tr>
<tr><td>PART_ID_H</td><td>1</td><td>分片ID高8位</td></tr>
<tr><td>PART_NUM_L</td><td>1</td><td>总分片数低8位</td></tr>
<tr><td>PART_NUM_H</td><td>1</td><td>总分片数高8位</td></tr>
</table>
>[!note]
>
>* **分片ID从1开始**
>
>* **每一片帧头包含的数据区长度为对应该片的数据长度而非总长度，最大为31**



4. 数据+校验位

<table>
<tr><td>字段</td><td>长度（字节）</td><td>说明</td></tr>
<tr><td>DATA</td><td>LEN</td><td>UTF-8 编码JSON文本</td></tr>
<tr><td>CHECKSUM</td><td>1</td><td>分片内数据校验码，按字节异或和计算，见下文校验算法</td></tr>
</table>



5. 校验算法

```
def calculate_checksum(data):
    checksum = 0
    for byte in data:
        checksum ^= byte
    return checksum & 0xFF
```



6. 读取内容说明

主机发送读取请求后(即读取地址)，WonderLLM应答后可能会发出两种类型信息：

(1) **平台大模型回传至模块的内容(如人机交互中大模型的回复，也包含回传的MCP工具JSON字符串)**  

(2) **WonderLLM当前的工作的状态码(长度1字节，不含校验位，人机交互未进行时均回复此类型内容)**


>[!note]
>
>**以上两种类型消息在发出前均会按长度分片，以UTF-8格式编码，并按指定上文指定格式封装为若干片“帧头”、“数据+校验位”依次发送至主机**



* #### **通信流程**

>[!note]
>
>* **下文通信流程以具备多线程运行能力/运行RTOS的主控为例进行讲解。**
>
>* **如果用户使用的主控仅支持单线程运行则只需关注1-5步，运行完前3步后，需要在主循环中轮询持续执行第4步的(3)-(5)小点步骤读取IIC接口。如果读取到正常数据并完成校验、重组处理，在主循环中按照第5步执行对应逻辑。**

1. 初始化阶段
   

(1) 主控扫描**I²C**总线，确认地址 **0x55** 存在

(2) 等待从机就绪（延时约100ms）



2. MCP工具注册

(1) 发送**MCP**工具注册指令（**move、run_action、get_status**等）

(2) 注意：扫描到**I²C**设备后要立刻发送**MCP**工具注册指令，否则大模型无法调用**MCP**工具



3. TTS服务配置

(1) 设置TTS模型（aliyun或volcengine），不能同时使用

(2) 设置应用ID和访问令牌（用于TTS服务认证）

(3) 支持多语言TTS功能（粤语、日语、韩语）



4. 数据收发循环

(1) 子线程每20ms执行一次回调函数

(2) 回调函数中处理发送队列中的数据

(3) 读取数据帧头部（8字节：帧头+数据长度+分片ID+总分片数）

(4) 根据分片信息读取数据并进行校验

(5) 处理分片数据重组（支持多分片传输）

(6) 将接收到的数据放入接收队列



5. 主循环处理

(1) 主线程从接收队列中取出数据进行解析

(2) 根据解析结果执行相应操作：

① 执行动作（run_action）

② 控制移动（go, turn, duration）

③ 读取传感器数据（get_status）

④ 处理视觉识别结果（vision）

⑤ 处理语音合成完成通知（tts_finish）

⑥ 处理大模型回复（reply）

执行完成后调用`action_finish`或`status`返回结果



6. 优先队列管理

(1) 发送队列和接收队列均使用优先队列管理

(2) 队列最大长度限制为10（通过max_heap_size属性设置），防止内存溢出

(3) 使用_thread锁机制确保多线程安全



7. 垃圾回收

(1) 回调函数中每100次迭代执行一次垃圾回收

(2) 主循环中每1000次迭代执行一次垃圾回收



## **2.2MicroPython**开发

### 2.2.1 MicroPython程序说明

* **准备工作**
>[!note]
>**在学习本节例程前，请确保已完成[“2.1 WonderLLM通信协议”](#anther2.1)的学习。**



* **接线说明**

>[!note]
>**MicroPython代码可在任意支持MicroPython编程的主控上运行，为讲解方便，此处以我司ESP32核心板为例讲解说明。**

1)  接线时，WonderLLM的5V、GND、SCL和SDA引脚需与ESP32核心板进行连接，接线方式如下图所示：

<img src="..\_static\media\chapter_2\section_2/media/image19.png" style="width:600px"  class="common_img" />


2)  ESP32核心板可与我司开源6路舵机控制器搭配使用，与WonderLLM的接线方式如下图：

<img src="..\_static\media\chapter_2\section_2/media/image20.png" style="width:600px"  class="common_img" />


>[!note]
>**通电前确保不要有金属物体接触到主板，否则可能会因主板底部的引脚导致电路短路从而烧毁主板。**



* **准备工作**

打开“**附录\01 MicroPython程序文件\main.py**”，将前文配置在线语音大模型平台得到的用户信息填入如下代码，点击保存关闭。

```python
if use_aliyun:
  control.set_tts_model("aliyun")
  control.send_message({"command":"app_id","params":""})         
  #在此填入阿里云平台创建应用的API_KEY
else:
  control.set_tts_model("volcengine")
  control.send_message({"command":"app_id","params":""})         
  #在此填入火山引擎平台创建应用的app_id
  control.send_message({"command":"access_token","params": ""})  
  #在此填入火山引擎平台创建应用的access_token
```



* **程序下载**

>[!note]
>
>* **Micropython支持多种IDE下载，如Thoony、VScode（需安装相关插件），相关操作请用户自行检索，此处以我司“幻尔python编辑器”下载程序为例，可实现免安装使用，开箱即用。**
>* **如使用ESP32，在下载Micropython前，需确保ESP32中已烧录Micropython固件，相关固件下载请见Micropython官网。如使用我司ESP32核心板，也可直接烧录我司提供固件文件（路径：\附录\03  ESP32核心板固件及烧录软件\02 ESP32固件烧录工具，烧录方式见同路径文档。**

1)  打开“**幻尔Python编辑器**”软件<img src="..\_static\media\chapter_2\section_2/media/image1.png"  style="width:50px" />（路径：**附录\02  幻尔python编辑器**）；

2)  将本文档路径下的“**附录\01 MicroPython程序文件\main.py**”文件，拖到幻尔Python编辑器中（需要拖到红框内区域才有效）；

    <img src="..\_static\media\chapter_2\section_2/media/image2.png" style="width:600px"  class="common_img" />

3)  点击菜单栏的连接按钮<img src="..\_static\media\chapter_2\section_2/media/image3.png" style="width:50px  " />，连接成功后会变为绿色的图标<img src="..\_static\media\chapter_2\section_2/media/image4.png" style="width:50px"  />；

4)  连接成功后点击菜单栏上的下载按钮<img src="..\_static\media\chapter_2\section_2/media/image5.png"  style="width:50px" />，将程序下载至ESP32内，等待下方信息交互方框内提示下载完成。

    <img src="..\_static\media\chapter_2\section_2/media/image6.png" style="width:600px"  class="common_img" />



* **测试案例**

1. 阶段1

调用阿里云/火山引擎平台的音色，合成播报各语种版本的“**你好，请问有什么可以帮到你的？**”。

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 12%" />
<col style="width: 52%" />
<col style="width: 28%" />
</colgroup>
<tbody>
<tr>
<td>顺序</td>
<td>所属平台</td>
<td>音色ID</td>
<td>语种</td>
</tr>
<tr>
<td>1</td>
<td>阿里云</td>
<td>longjiayi_v2</td>
<td>粤语</td>
</tr>
<tr>
<td>2</td>
<td>阿里云</td>
<td>loongtomoka_v2</td>
<td>日语</td>
</tr>
<tr>
<td>3</td>
<td>阿里云</td>
<td>loongkyong_v2</td>
<td>韩语</td>
</tr>
<tr>
<td>1</td>
<td>火山引擎</td>
<td>zh_female_shuangkuaisisi_emo_v2_mars_bigtts</td>
<td>英语</td>
</tr>
<tr>
<td>2</td>
<td>火山引擎</td>
<td>zh_male_guangxiyuanzhou_moon_bigtts</td>
<td>国语</td>
</tr>
<tr>
<td>3</td>
<td>火山引擎</td>
<td>zh_female_yuanqinvyou_moon_bigtts</td>
<td>国语</td>
</tr>
</tbody>
</table>

2. 阶段2

调用3次视觉识别功能，使模块根据实时捕获画面，分别就给出的3个提示语句做出回复(主控串口打印供查看)。

<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr>
<td>顺序</td>
<td>提示词</td>
</tr>
<tr>
<td>1</td>
<td>识别画面中有没有人，有就返回true，否则返回false，你的返回只能是true或者false， 不要任何解释和说明</td>
</tr>
<tr>
<td>2</td>
<td>识别画面中有没有人，有就返回'有人'，否则返回'没人'，你的返回只能是'有人'或者'没人'， 不要任何解释和说明</td>
</tr>
<tr>
<td>3</td>
<td>Describe what you see in 20 words</td>
</tr>
</tbody>
</table>
3. 阶段3

以WonderLLM模块人机交互解决方案为例，在WonderLLM基础人机交互功能以外，向模块注册自定义MCP工具，实现若干机器人控制功能。在WonderLLM进入聊天模式后，可参照以下调用示例控制模块使用对应MCP功能。

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 12%" />
<col style="width: 52%" />
<col style="width: 28%" />
</colgroup>
<tbody>
<tr>
<td>序号</td>
<td>MCP工具名</td>
<td>说明</td>
<td>调用示例</td>
</tr>
<tr>
<td>1</td>
<td>运动控制</td>
<td>你要做动作时调用这个工具。可选动作有:'sit_dowm':坐下, 'go_prone':趴下，'stand': 立正"</td>
<td>控制机器人立正</td>
</tr>
<tr>
<td>2</td>
<td>行进控制</td>
<td>你要移动时调用这个工具。可以控制前进后退，左转右转，前进步幅默认20, 后退步幅默认-20, 单位mm，左转步幅默认20, 右转步幅默认-20, 单位度，停止速度就都是0, 移动时的持续时间，单位毫秒",</td>
<td><p>①向前走1000毫秒</p>
<p>②以15毫米的步幅左转1000毫秒</p></td>
</tr>
<tr>
<td>3</td>
<td>状态查询</td>
<td>你要获取机器人实时状态或者传感器数据时调用这个工具。包括battery，pose, touch_sensor, light_sensor等, 站着时姿态趋近0,坐着时姿态趋近-90",</td>
<td><p>①查询机器人当前运动姿态</p>
<p>②查询机器人当前电量</p></td>
</tr>
</tbody>
</table>


* **程序分析**

1)  导入库函数，实例化IIC接口对象i2c，与主控的IIC1绑定并指定其在主控上的引脚号，以400K速率开始工作。

```python
import gc
import time
import heapq
import ujson
import struct
import _thread
from machine import Pin, I2C
print("Stopping...")
i2c = I2C(1, scl=Pin(13), sda=Pin(19), freq=400000)
```

2)  定义`mcp_move_dict`等用户自定义MCP工具字符串字典，按规则在`tool_name`等键中填入自定义字符串。 

```python
# 使用示例
mcp_move_dict = {
    "tool_name":   "self.robot.move",
    "command":     "你要移动时调用这个工具。可以控制前进后退，左转右转，前进步幅默认20, 后退步幅默认-20, 单位mm，左转步幅默认20, 右转步幅默认-20, 单位度，停止速度就都是0, 移动时的持续时间，单位毫秒",
    "params":      [["go", "int", "-20", "20"], ["turn", "int", "-20", "20"], ["duration", "int"]],
    "block":       "true",
    "return":      "false", 
}   

mcp_run_action_dict = {
    "tool_name":   "self.robot.run_action",
    "command":     "你要做动作时调用这个工具。可选动作有:'sit_dowm':坐下, 'go_prone':趴下，'stand': 立正",
    "params":      [["run_action", "string"]],
    "block":       "true", #是否要让大模型等动作完成再继续, 注意当return为true时，block设置不生效，因为return本身就是阻塞的
    "return":      "false",
}

#设置mcp，调用mcp时会触发从机返回params格式数据回来，其中string会由大模型给出，跟你跟大模型的对话决定，例如你要求获取当前姿态，那么他就可能返回的是pose
#注意command里要描述清楚有哪些返回的选项，return表示是否需要返回数据给从机，如果需要，那么返回的数据按send_status的要求给出，他是一个列表
#如[["pose", "0"], ["battery", 8000]], 从机接收到后会原样返回给大模型让他进行判断或者播报
mcp_status_dict = {
    "tool_name":   "self.robot.get_status",
    "command":     "你要获取机器人实时状态或者传感器数据时调用这个工具。包括battery，pose, touch_sensor, light_sensor等, 站着时姿态趋近0,坐着时姿态趋近-90",
    "params":      [["get_status", "string"]],
    "block":       "true",
    "return":      "true",
}
```

3)  实例化`Controller`类（用于与WonderLLM交互）对象`conrtrol`，并与物理接口对象i2c绑定，内部初始化发送队列、接收队列、线程锁，同时在IIC总线上持续扫描WonderLLM(设备地址0x55)，直到模块接入主控IIC接口并被扫描到，才进行后续操作。

```python
control = Controller(i2c)
```

4. 调用`control.send_message`函数，将`mcp_move_dict`等用户自定义MCP工具字符串以JSON格式封装，通过IIC传输至WonderLLM，完成MCP工具注册。

>[!note]
>
>* **需要在模块白色滚动条加载完成前，即配网工作完成前，完成注册，联网完成后向模块注册的MCP指令无效，因此该函数不可过晚执行**
>* **WonderLLM上电后，内部也需要一定时间进行配置，不建议上电后立刻发送JSON字符串注册MCP工具，否则可能导致注册失败，系统整体上电后1-2s后调用发送即可**

```python
control.send_message(mcp_move_dict)
control.send_message(mcp_run_action_dict)
control.send_message(mcp_status_dict)
```

5)  往后执行，调用`control.start()`，在内部调用`send_message`函数将系统MCP工具字符串`mcp_finish_setting_dict`传输至模块，告知模块自定义MCP工具全部发送完成，并调用`start_new_thread`新建一个线程，其中运行`callback`函数，用于收发模块IIC数据并解析接收数据，初始化动作组执行完毕标志位并置为true。

```python
control.start()
action_finish = True
```

6)  将程序测试阶段变量**status**设为**tts_test**，后续程序会从语音测试开始执行。将调用语音模型**use_aliyun**指定为**True**，后续将阿里云有关的用户参数发送至模块，调用阿里云所属的三款音色进行语音合成测试。

```python
status = 'tts_test'
use_aliyun = True #语音合成功能使用模型(true-阿里云  false-火山引擎)

if use_aliyun:
  control.set_tts_model("aliyun")
  control.send_message({"command":"app_id","params":""})         #在此填入阿里云平台创建应用的app_id
else:
  control.set_tts_model("volcengine")
  control.send_message({"command":"app_id","params":""})         #在此填入火山引擎平台创建应用的app_id
  control.send_message({"command":"access_token","params": ""})  #在此填入火山引擎平台创建应用的access_token
```

7. 将语音合成测试阶段变量**tts_status**设为0，后续将从第一个音色开始测试，将**tts_finish**设为**true**（**当前已完成语音播报/模块未在播报**）

```python
tts_status = 0    #语音合成功能测试内容选择（0-2），会依次执行
tts_finish = True #语音合成完成标志位(true-完成本轮合成播报  false-正在合成播报)
```

8. 定义用于测试TTS语音合成功能的函数`tts_test()`，进入函数首先检查**tts_finish**（**语音合成播报完毕**），仅当其为真时才执行内部内容，避免当前模块正在播报的语音被主控新发来的TTS指令打断。

```c
def tts_test():
  global tts_status, status, tts_finish

  if tts_finish:
```

9. 以使用阿里云模型所属音色进行测试为例，在每个分支中，依次调用一个音色播报测试语句。最后1个分支执行完后，程序测试阶段变量**status** 设为**vision_test**，后续将跳转执行阶段2的视觉识别测试。

```c
    if use_aliyun:
      if tts_status == 0:      
        control.set_voice("粤英女")
        control.tts("你好，有咩可以幫到你嘅?")  
        tts_status = 1
      elif tts_status == 1:     
        control.set_voice("日语女")
        control.tts("こんにちは。何かご用でしょうか?")       
        tts_status = 2
      elif tts_status == 2:    
        control.set_voice("韩语女")
        control.tts("안녕하세요. 무엇을 도와드릴까요?")   
        tts_status = 3
      elif tts_status == 3:
        tts_status = 4
        status = 'vision_test' 
```

10. 将视觉识别测试阶段变量**vision_status**设为0，后续将从第一个提示词开始测试，将**vision_finish**设为**true**（**当前已完成视觉识别/模块未在识别画面**）

```python
vision_status = 0    #视觉识别功能测试内容选择（0-2），会依次执行
vision_finish = True #视觉识别完成标志位(true-完成本轮识别  false-正在进行识别)
```

11. 定义用于测试视觉识别功能的函数`vision_test()`，进入函数首先检查**vision_finish**（**视觉识别完毕**），仅当其为真时才执行内部内容，避免当前模块正在识别画面被主控新发来的视觉识别指令打断。三个视觉识别测试结束后，程序测试阶段变量**status** 设为**finish**。

```python
def vision_test():
  global vision_status, status, vision_finish
  if vision_finish:
    if vision_status == 0:
      control.vision("识别画面中有没有人，有就返回true，否则返回false，你的返回只能是true或者false， 不要任何解释和说明")
      vision_status = 1
    elif vision_status == 1:
      control.vision("识别画面中有没有人，有就返回'有人'，否则返回'没人'，你的返回只能是'有人'或者'没人'， 不要任何解释和说明")  
      vision_status = 2 
    elif vision_status == 2:
      control.vision("Describe what you see in 20 words")  
      vision_status = 3 
      status = 'finish'
    vision_finish = False 
```

12. 在循环中，根据程序测试阶段变量**status**在不同的if分支执行内容，当全部音色测试完毕，`tts_test()`内部将**status**跳转至分支**vision_test**；当全部视觉识别测试完毕，`vision_test()`内部将**status**跳转至分支**finish**；从而避免语音合成测试函数、视觉识别测试函数被多次执行

```python
      if status == 'tts_test':
        tts_test()
	  #tts_test()内所有测试项完成后，status切换至'vision_test'
      elif status == 'vision_test':
        vision_test()
```

13. 在主循环中，使用`loop_counter`进行计数，每循环1000次(每次循环执行时均延时0.1s，大约100s触发1次)调用`gc.collect()`，对程序各处临时变量使用过的内存空间进行整合，避免可用空间碎片化，无法再分配给程序使用。

```python
try:
    while True:
        loop_counter += 1
        # if test >= 0:
          # test += 1
        # if test == 10:
          # control.vision("识别画面中有没有人，有就返回true，否则返回false，你的返回只能是true或者false， 不要任何解释和说明")
        # if test > 10:
          # test = 11
        # Periodic garbage collection in main loop too
        if loop_counter % 1000 == 0:
            gc.collect()
            # print(f"Main loop GC at iteration {loop_counter}")
```

14. 每一轮循环，调用1次`control.get_message()`，读取并解析WonderLLM发来的IIC数据并将返回值存储至data，随后校验data。若为空，则不执行任何内容，若不为空，则进行进一步处理（在6)进行说明）。校验完成后，延时0.1S进入下一轮循环。

```python
        data = control.get_message()
        if data:
```

```python
        else:
          pass
          # print('wait')
            
        time.sleep(0.1)
```

15. 接上文，本步骤讲解获取模块IIC数据后的进一步处理：首先判断当前接收到的数据是否属于模块常规状态信息，若不是则属于MCP工具字符串信息。

>[!note]
>**当WonderLLM没有接收到小智AI平台发回的MCP工具消息时，与模块通信，返回的是当前模块的工作状态（用1字节表示），反之在与模块通信时，WonderLLM将接收到的MCP工具消息（JSON格式）从IIC总线直接转发给主控。**

   ```python
               if data not in control.status:
   ```

16. 若属于模块常规状态信息，则进一步检测当前常规状态信息是否为**‘listening’（模块正在倾听用户新一轮发言）**，检测动作组执行完毕标志位是否置true判断机器人是否正在运动，若是则调用`control.sleep()`发送让WonderLLM休眠待机，避免当前执行动作被打断。

```python
            else:
                if 'listening' in data:
                  if not action_finish:
                    print('stop')
                    action_finish = True
                    control.sleep()   
```

17. 若属于MCP工具字符串信息，首先将接收到的原始数据打印出来，之后逐个匹配关键词的方式确认当前MCP指令的类型并执行对应操作，下文以其中两类举例说明。

```python
            if data not in control.status:
                print("Received data from queue:", data)
                action_finish = False
                
                try:
                    if 'run_action' in data:
                        action_name = data.get('run_action', '')
                        print(action_name)
                        time.sleep(1) #确保动作完成需要的时间   
                        control.send_action_finish("true")  #告诉大模型动作完成了可以继续了
                    elif 'go' in data or 'turn' in data:
                        go = data.get('go', 0)
                        turn = data.get('turn', 0)
                        duration = data.get('duration', 1000)
                        
                        print(go, turn)
                        time.sleep_ms(duration)
                        print('stop') #手动停止
                        control.send_action_finish("true")      
                    elif 'get_status' in data:
                        status_request = data.get('get_status', '')
                        if 'pose' in status_request:
                            angle = 90 #读取传感器的数据，这里手动设置
                            robot_status.append(["pose", str(angle)])
                        if 'battery' in status_request:
                            robot_status.append(["battery", "10V"])
                        if robot_status:
                            control.send_status(robot_status)
                            robot_status.clear()
                    elif 'vision' in data:
                      print(data['vision'])
                except Exception as e:
                    print(f"Action execution error: {e}")
```

18. 若为调用动作组的MCP工具消息，则接收数据中`run_action`字段的动作组名称并打印输出，最后调用`control.send_action_finish("true")`回复模块指令执行完毕。

>[!note]
>
>* **该类MCP工具阻塞式执行（block=true），执行完毕需调用基础系统指令action_finish回复WonderLLM。**
>* **此处用户可将取出的动作组名称传入自定义的动作组执行函数执行动作组，此处仅作简单打印示意处理。**

```python
                    if 'run_action' in data:
                        action_name = data.get('run_action', '')
                        print(action_name)
                        time.sleep(1) #确保动作完成需要的时间   
                        control.send_action_finish("true")  #告诉大模型动作完成了可以继续了
```

19. 若为读取电池电压状态的MCP工具消息，需要向模块回传指定数据，将电压数据按JSON格式封装为JSON字符串并调用`append`存入robot_status，在另一个线程中会将其取出并从IIC总线发送给模块。

>[!note]
>**回复内容客户可自行组织，大模型会自行完成语义理解，用户仅需保证：①说明参数名称 ②注明数值、单位防止误读 ③符合JSON格式 即可。**

```python
                    elif 'get_status' in data:
                        status_request = data.get('get_status', '')
                        if 'pose' in status_request:
                            angle = 90 #读取传感器的数据，这里手动设置
                            robot_status.append(["pose", str(angle)])
                        if 'battery' in status_request:
                            robot_status.append(["battery", "10V"])
                        if robot_status:
                            control.send_status(robot_status)
                            robot_status.clear()
```

20. 其他类型数据处理逻辑与上文高度相似，此处不再过多说明。



### 2.2.2程序文件

**路径：附录\01 MicroPython程序文件\main.py**


<p id = "anther2.2.3"></p>
### 2.2.3幻尔python编辑器

>[!note]
>**如果出现编辑器打不开的情况，请将编辑器的名称更改为全英文，例如“Hiwonder”。**

* **功能介绍**

1. 我们将当前编辑器的界面分为了五部分，如下图所示：

<img src="..\_static\media\chapter_2\section_2\media\image1_1.png" style="width:600px"  class="common_img" />

2. 每个区域都有相对应的功能，具体功能如下表所示：

<table>
<tr><td>序号</td><td>区域名称</td><td>作用</td></tr>
<tr><td>1</td><td>菜单栏</td><td>包含文件、编辑、视图、连接、运行、帮助。</td></tr>
<tr><td>2</td><td>工具栏</td><td>包含了部分常用的快捷按键，与菜单栏部分按键的实现效果相同</td></tr>
<tr><td>3</td><td>文件列表</td><td>分为设备内和本地内的多个项目文件，可查看项目文件内容（文件夹、源代码等）。</td></tr>
<tr><td>4</td><td>代码编辑区</td><td>可以查看和编写代码。</td></tr>
<tr><td>5</td><td>终端</td><td>可查看消息日志与调试信息。当未连接设备时，仅可查看消息日志。</td></tr>
</table>


* **操作说明**

1. 导入本地项目

(1) 初次导入本地项目时，左键单击**“本地项目”**即可弹出文件选择列表。（后续再次导入时，右击“**本地项目-\>切换项目路径**”即可）。

<img src="..\_static\media\chapter_2\section_2\media\image2_1.png" style="width:500px"  class="common_img" />

(2) 选择存放MicroPython程序的路径，点击“**选择文件夹**”按钮。

<img src="..\_static\media\chapter_2\section_2\media\image3_1.png" style="width:500px"  class="common_img" />

(3) 文件夹内的文件会自动添加至本地项目中，在“**本地项目**”处可看见。

<img src="..\_static\media\chapter_2\section_2\media\image4_1.png" style="width:500px"  class="common_img" />

>[!note]
>**导入本地项目是将电脑文件导入至编辑器内，并非下载至ESP32核心板中。**



2. 查看导入的文件/程序

这里我们双击文件列表内的程序文件查看详细代码，此处以“**march_on_the_spot.py**”为例：

<img src="..\_static\media\chapter_2\section_2\media\image5_1.png" style="width:600px"  class="common_img" />

同理，将程序文件下载至ESP32核心板后，可在“**设备**”列表下双击查看程序文件。



3. 代码编写与储存

界面右侧的代码编辑区支持代码创建、查看、编辑、修改、储存等功能。在开始编写代码前，需要阅读以下注意事项：

(1) 用户无法直接在“设备”标签内创建文件，且**“设备”**内的文件只能通过下载的方 式来保存修改内容。如需备份，可先复制至本地项目中。

(2) 请勿在编辑器内修改文件后缀为**“rob”**的动作组文件，以免引发未知的格式错误。 如需修改动作组文件，可在上位机内进行。

(3\) 提供的底层程序文件中，main.py 为设备的主程序，机器人上所有的功能都需通过该文件的启动来实现，即复位与开机操作都需要执行该程序，如果它处于卡死状态，后续的其他操作都无法进行。 因此，如果用户需要在该文件内部增加功能，保险起见，建议先修改程序名称。若将 main.py 命名为其它名字，即使调试程序时出现特殊卡死现象（快捷键**“Ctrl+C”**和**“Ctrl+D”**都失效），只需将控制板复位，删除并重新下载所需程序。



4. 程序下载与运行

程序的下载是编辑器与设备之间的交互行为。此处以“**march_on_the_spot.py**”为例：

(1) 选择“**本地项目**”标签内的**“Hello.py”**文件后，点击工具栏的图标<img src="..\_static\media\chapter_2\section_2\media\image6_1.png" style="width:50px" />，或直接右键该文件选择“**下载并运行**”

<img src="..\_static\media\chapter_2\section_2\media\image7_1.png" style="width:500px"  class="common_img" />

(2) 可在终端界面中，查看下载进度及完成状态。上一步选择的是“**下载并运行**”，因此还可以查看程序的运行效果。

<img src="..\_static\media\chapter_2\section_2\media\image8_1.png" style="width:500px"  class="common_img" />

(3) 下载完成后，程序会出现在“**设备**”标签下的文件列表内。

<img src="..\_static\media\chapter_2\section_2\media\image9_1.png" style="width:500px"  class="common_img" />

(4) 最后将原先的**“main.py”**文件删除，将下载的“**change_speed.py**”重命名为“**main.py**”即可。

<img src="..\_static\media\chapter_2\section_2\media\image10_1.png" style="width:500px"  class="common_img" />

(5)此外，还有几点需要用户知悉：

①除了这种下载方式之外，同样还可以先将需要下载的文件，提前更名为**“main.py”**再进行下载。

②“**下载并运行**”功能是先对设备进行复位，即重启，随后下载并运行程序，这样有利于程序运行的稳定性。

③如果无需立刻执行程序，可以点击按钮<img src="..\_static\media\chapter_2\section_2\media\image11_1.png" style="width:40px" />，或右键目标文件选择“**下载**”即可。在后边需要执行程序前，我们可以先按<img src="..\_static\media\chapter_2\section_2\media\image12_1.png" style="width:40px" />图标，进行设备复位再执行程序。



5. 终端使用方法（调试）

(1) 终端是集信息窗口与调试界面于一体的功能区域。但需要说明的是，如果未连接设备，终端区域仅做信息查看作用，无法编辑和调试。

(2) 关于信息查看，在前面步骤中大家已经有所体验，因此不再细说。这里主要对调试方面的功能进行说明。

① 终端支持输入代码。在终端输入代码“print(123)”并按下回车，效果如下：

<img src="..\_static\media\chapter_2\section_2\media\image13_1.png" style="width:600px"  class="common_img" />

② 此外，终端也支持自动缩进。在键入以冒号结尾的 python 语句（如 if、for、while），并按下回车键时，下一行将以 常规语句的相同缩进级别继续，或在适当情况下以其他缩进级别继续。如果按退格键，它将撤消一级缩进。

<img src="..\_static\media\chapter_2\section_2\media\image14_1.png" style="width:600px"  class="common_img" />

③ 如需复制和粘贴代码，可在选中目标代码后，在终端界面处右键进行操作。

<img src="..\_static\media\chapter_2\section_2\media\image15_1.png" style="width:200px"  class="common_img" />

>[!note]
>**需要注意的是，由于终端具备自动缩进的功能，粘贴代码前，需要按下“Ctrl+E”进入编辑模式，否则调试会出现缩进错误。**

④ 下图是采用正确方法进行复制粘贴的效果图，缩进格式正确。

<img src="..\_static\media\chapter_2\section_2\media\image16_1.png" style="width:600px"  class="common_img" />

⑤ 下图为错误缩进格式：

<img src="..\_static\media\chapter_2\section_2\media\image17_1.png" style="width:600px"  class="common_img" />

⑥ 如需退出编辑模式，可按**“Ctrl+C”**。此外，如果编写了一个死循环，也可按下“Ctrl+C”退出。
>[!note]
>
>* **在终端内，“Ctrl+C”快捷键只可用于中断已运行的程序，不具备复制功能，且“Ctrl+V”无粘贴作用。**
>* **在终端输入命令时，可以使用“Tab”键来补齐代码。例如，在终端处输入“os”后，按下“Tab”键，效果如下：**
>  **<img src="..\_static\media\chapter_2\section_2\media\image18_1.png" style="width:500px"  class="common_img" />**
>   **如果当前代码可衔接的内容有两种或以上，终端处会列举出所有选项；如果只有一种，终端会自动补齐；如果没有，就无作用。**
>* **在终端处，可通过键盘的“↑”、“↓”键查看输入命令的历史记录，节省输入时间。关于更多命令以及命令说明，可前往<http://docs.micropython.org/en/latest/library/uos.html>进行查看。**


<p id = "anther2.2.4"></p>
### 2.2.4ESP32核心板固件及烧录软件

* **设备连接**

将ESP32核心板Type-C接口通过USB线接入电脑，如下图。

<img src="..\_static\media\chapter_2\section_2\media\image1_2.png" style="width:500px"  class="common_img" />



* **操作流程**

1. 请打开路径文件下"**附录\03  ESP32核心板固件及烧录软件\02 ESP32固件烧录工具**"压缩包目录下的**flash_download_tool_3.9.7.exe**文件。

   <img src="..\_static\media\chapter_2\section_2\media\image2_2.png" style="width:500px"  class="common_img" />

2. 选择Chip Type为ESP32，其他保持默认，然后点击OK。

   <img src="..\_static\media\chapter_2\section_2\media\image3_2.png" style="width:500px"  class="common_img" />

3. 工具打开后，点击“...”选择需要烧录的程序bin文件（存放路径：本文档下载链接文件下[03 ESP32核心板固件]()）。

   <img src="..\_static\media\chapter_2\section_2\media\image4_2.png" style="width:500px"  class="common_img" />

   <img src="..\_static\media\chapter_2\section_2\media\image5_2.png" style="width:500px"  class="common_img" />

4. 左侧需打勾，其余配置按照下图所示进行配置即可，COM端口号选择模块所占的端口号。
>[!note]
>**如果您按下图的配置，将SPI MODE设置为DIO，烧录固件后模块无法正常工作；请尝试将SPI MODE设置为DOUT并再次烧录。**

<img src="..\_static\media\chapter_2\section_2\media\image6_2.png" style="width:500px"  class="common_img" />

5. 先点击"**ERASE**"擦除之前下载的固件(一定要进行)，等待状态栏显示“**FINISH完成**”。

   <img src="..\_static\media\chapter_2\section_2\media\image7_2.png" style="width:500px"  class="common_img" />

   <img src="..\_static\media\chapter_2\section_2\media\image8_2.png" style="width:500px"  class="common_img" />

6. 再点击"**START**"下载刚刚选择的固件，等待进度条加载完成，即完成固件下载。

<img src="..\_static\media\chapter_2\section_2\media\image9_2.png" style="width:500px"  class="common_img" />

<img src="..\_static\media\chapter_2\section_2\media\image10_2.png" style="width:500px"  class="common_img" />

7)  下载完成后，重新拔插数据线，设备重新上电后，即根据新固件程序开始工作。



## **2.3Arduino开发**

### 2.3.1MCP工具使用

* #### **MCP工具使用程序说明**

>[!note]
>**注意：在学习本节例程前，请确保已完成[“2.1 WonderLLM通信协议”](#anther2.1)的学习。**



1. 接线说明

(1) 接线时，WonderLLM的5V、GND、SCL和SDA引脚需与Arduino UNO开发板进行连接，接线方式如下图所示：

<img src="../_static/media/chapter_2/section_3/media/image14.png" style="width:500px"  class="common_img" />

(2) Arduino UNO开发板可与我司任意一款Arduino扩展板搭配使用，与WonderLLM的接线方式如下图（以A板为例）：

<img src="../_static/media/chapter_2/section_3/media/image15.png" style="width:500px"  class="common_img" />

>[!note]
>**注意：通电前确保不要有金属物体接触到主板，否则可能会因主板底部的引脚导致电路短路从而烧毁主板。**



2. 程序下载

(1) 将Arduino UNO开发板通过数据线连接至电脑。

(2) 打开本文档路径下的**“附录\04  Arduino程序文件\01 MCP工具使用\WonderLLM_example”**程序文件。

<img src="../_static/media/chapter_2/section_3/media/image1.png" style="width:500px"  class="common_img" />

(3) 开发板选择Arduino UNO，并选择正确的端口号。

<img src="../_static/media/chapter_2/section_3/media/image2.png" style="width:500px"  class="common_img" />

(4) 点击<img src="../_static/media/chapter_2/section_3/media/image3.png" style="width:40px" />，将程序下载至开发板中，等待下载完成即可。

<img src="../_static/media/chapter_2/section_3/media/image4.png" style="width:500px"  class="common_img" />

<img src="../_static/media/chapter_2/section_3/media/image5.png" style="width:500px"  class="common_img" />



3. 测试案例

本例程以WonderLLM模块车机交互解决方案为例，在WonderLLM基础人机交互功能以外，向模块注册自定义MCP工具，实现若干小车控制功能。在WonderLLM进入聊天模式后，可参照以下调用示例控制模块使用对应MCP功能。

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 12%" />
<col style="width: 52%" />
<col style="width: 28%" />
</colgroup>
<tbody>
<tr>
<td>序号</td>
<td>MCP工具名</td>
<td>说明</td>
<td>调用示例</td>
</tr>
<tr>
<td>1</td>
<td>蜂鸣器控制</td>
<td>控制小车的蜂鸣器时调用这个工具。'count'是蜂鸣器响的次数</td>
<td>控制蜂鸣器响5声</td>
</tr>
<tr>
<td>2</td>
<td>LED灯控制</td>
<td>设置左右RGB灯颜色。lr,lg,lb是左灯RGB, rr,rg,rb是右灯RGB, 范围0-255</td>
<td><p>①控制左侧RGB灯亮纯绿色</p>
<p>②控制两侧RGB灯红光亮度0，绿光亮度255，蓝光亮度255</p></td>
</tr>
<tr>
<td>3</td>
<td>运动模式控制</td>
<td><p>切换小车的模式时调用这个工具。'distance'只在避障模式下使用。"</p>
<p>"可切换的模式包括：'avoid', 'line_patrol','smart_line_patrol','normal'</p></td>
<td><p>①小车进入避障模式，前方50cm内检测到障碍物自动避开</p>
<p>②小车进入巡线模式</p></td>
</tr>
<tr>
<td>4</td>
<td>状态查询</td>
<td><p>获取小车的实时状态时调用这个工具。"</p>
<p>"可查询的状态包括：'battery', 'angle', 'distance', 'running_mode'</p></td>
<td><p>①查询小车当前运动状态</p>
<p>②查询小车当前电量</p></td>
</tr>
<tr>
<td>5</td>
<td>转向控制</td>
<td>控制小车原地旋转时调用这个工具。direction参数控制方向，'left'或'right'。angle参数控制旋转的角度，单位是度(°)</td>
<td>小车左转15度</td>
</tr>
<tr>
<td>6</td>
<td>行进控制</td>
<td>控制小车移动时调用这个工具。move参数控制前后运动方向，'forward'或'backward'。distance参数控制距离，单位是厘米(cm)</td>
<td>小车前进50厘米</td>
</tr>
</tbody>
</table>


4. 实现效果
>[!note]
>
>* **打开串口调试助手，波特率选择115200，编码格式选择UTF-8**

1. 上电工作后，Arduino UNO主控会自行完成MCP工具注册，在WonderLLM模块正式开始工作后调用一次视觉识别功能识别当前环境，最后轮询检测用户语音交互调用自定义MCP工具后WonderLLM回传的数据。

<img src="..\_static\media\chapter_2\section_3\media/image17.png" style="width:1000px"  class="common_img" />

2. 以行进控制功能为例，用户可在WonderLLM进入聊天模式时，说出**“小车前进50厘米”**调用对应功能，WonderLLM**“行进控制”**工具激活后，通过IIC总线回传指令（JSON格式），Arduino UNO主控接收到后会自行解析并执行。

<img src="..\_static\media\chapter_2\section_3\media/image16.png" style="width:800px"  class="common_img" />



5. **程序简要分析**

>[!note]
>**模块库函数文件分为WonderLLM、WonderLLM_porting两类文件，WonderLLM_porting为主控实现模块交互底层的硬件库函数适配代码，WonderLLM为主控与模块交互读取数据的逻辑层代码。**

(1) 导入WonderLLM模块库WonderLLM.h用于与模块交互。

```c
#include "WonderLLM.h"
```

(2) 声明存储模块回传MCP指令解析结果的外部变量WonderLLM_hiwonder。

```c
extern WonderLLM_Info WonderLLM_hiwonder;
```

(3) 在`setup`函数中，等待2s，确保WonderLLM模块内部IIC底层硬件配置已完成。

```c
void setup() {
  Serial.begin(115200);
  Wire.begin();
  /*WonderLLM模块上电后:
      1.需要在模块白色滚动条加载完成前，即配网工作完成前，必须调用WonderLLM_Init()将MCP工具以json格式发往模
        块完成注册，联网完成后向模块注册的MCP指令无效，因此该函数不可过晚执行
      2.WonderLLM上电后，内部也需要一定时间进行配置，不建议上电后立刻调用WonderLLM_Init发送，可能导致注册
        失败，系统整体上电后1-2s后调用WonderLLM_Init发送即可
  */
  delay(2000);	
```

(4) 调用`WonderLLM_Init`函数初始化模块，在内部先扫描检测WonderLLM是否已接入IIC总线。若是则将总线速率提升至400K并将MCP提示字符串(prompt)依次发送到模块，完成自定义MCP工具的注册；若不是则持续扫描等待，超过5秒仍未找到则判定初始化失败并退出。

```c
  WonderLLM_Init(); //初始化WonderLLM模块	
  Serial.print(F("welcome to use hiwonder's sensor!\r\n"));
```

(5) 等待18s，确保模块已完成前期配网准备并正式开始工作（模块白色滚动条消失，进入表情界面），调用`WonderLLM_Request_Vision`视觉识别功能（即摄像头模式的场景理解功能）并传入对应的提示字符串。

```c
  //调用一次模块视觉识别功能
  //WonderLLM_Request_Vision传入的提示符字符串内部不能包含双引号，否则会导致解析失败
  //延时一段时间，确保模块已经上电，并完成配网（出现表情界面）
  delay(18000);

  Get_PromptData_on_flash(info,vision_prompt);
  Serial.println(info); 
  delay(1000);

  WonderLLM_Request_Vision(info);	
```
>[!note]
>
>* **模块完成配网前，调用该函数无效。用户可根据实际模块配网时长灵活调整程序中18s的延时时间。**
>
>* **字符串可由用户自由组织语言，支持中/英文输入。请确保表意简洁，突出识别目的及返回内容**
>
>* **由于Arduino芯片资源有限，过多的字符串会占用大量的动态内存，因此，各类MCP提示字符串均存储于Flash中，需调用Get_PromptData_on_flash读取并转存至Flash_data_temp后再作为参数传入其他函数使用。**

(6) 调用`WonderLLM_Info_Get`函数，读取实时从IIC总线接收解析的WonderLLM数据，并转存至WonderLLM_hiwonder。

```c
void loop() {

  //获取WonderLLM数据
  WonderLLM_Info_Get(&WonderLLM_hiwonder); 
```

(7) 检测WonderLLM_hiwonder存放数据类型的Frame_mode成员，若等于Frame_NULL，说明没有获取到有效数据，程序延时一段时间后开始下一轮循环。反之说明获取到了有效的WonderLLM回传数据，首先将json_data_raw成员存储的回传的原始数据串口打印输出，随后清空该空间用于下一次接收。

```c
if(WonderLLM_hiwonder.Frame_mode != Frame_NULL){
  sprintf(info,"raw str:%s\r\n",WonderLLM_hiwonder.json_data_raw);

  memset(WonderLLM_hiwonder.json_data_raw,0,sizeof(WonderLLM_hiwonder.json_data_raw));
  Serial.print(info); 
```

(8) 程序根据数据类型Frame_mode执行不同的处理逻辑，在Frame_move中，该类型字符串包含参数distance，在解析中将该项数据存放至motion_target_distance。将其打印并传入用户运动控制API（如有），最后调用`WonderLLM_Send_Action_Finish`回复WonderLLM，该MCP操作已执行完成。

```c
case Frame_move:{
  sprintf(info,"Frame_move:diatance:%d\r\n",WonderLLM_hiwonder.motion_target_distance);
  Serial.print(info);

  /* 执行用户自定义运动控制API */

  //该类MCP工具阻塞式执行（block=true），执行完毕需调用基础系统指令action_finish回复WinderMind
  WonderLLM_Send_Action_Finish();							
  break;
}
```

(9) 在Frame_get_status_battery中，需要向模块回传指定数据，将电压数据按JSON格式封装为JSON字符串，最后调用`WonderLLM_Send_Status`从IIC发出。

>[!note]
>**回复内容客户可自行组织，大模型会自行完成语义理解，用户仅需保证：①说明参数名称 ②注明数值、单位防止误读 ③符合JSON格式 即可。**

```c
case Frame_get_status_battery:{
  //此处假定系统电压为7.4v，实际应用时应将voltage用于承接用户提供的获取电压API的返回值
  int voltage = 7400; //单位：mv
  sprintf(info, "[\"battery\",\"%d\",\"mV\"]", voltage);

  // //该类MCP工具需返回参数给WonderLLM（return=true），执行完毕需调用基础系统指令status按指定格式回传参数
  WonderLLM_Send_Status(info);
  break;
}
```

(10) 其他类型数据处理逻辑与上文高度相似，此处不再过多说明。



### 2.3.2 TTS语音合成功能

* #### TTS语音合成功能说明

>[!note]
>**在学习本节例程前，请确保已完成[“2.1 WonderLLM通信协议”](#anther2.1)的学习。**

1. **接线说明**

(1) 接线时，WonderLLM的5V、GND、SCL和SDA引脚需与Arduino UNO开发板进行连接，接线方式如下图所示：

<img src="../_static/media/chapter_2/section_3/media/image14.png" style="width:500px"  class="common_img" />


(2) Arduino UNO开发板可与我司任意一款Arduino扩展板搭配使用，于WonderLLM的接线方式如下图（以A板为例）：

<img src="../_static/media/chapter_2/section_3/media/image15.png" style="width:500px"  class="common_img" />


>[!note]
>**通电前确保不要有金属物体接触到主板，否则可能会因主板底部的引脚导致电路短路从而烧毁主板。**



2. **准备工作**

打开“**附录\04  Arduino程序文件\01 MCP工具使用\WonderLLM_example**”,将前文配置在线语音大模型平台得到的用户信息填入如下代码，点击保存关闭。

```c
const char TTS_model_uesr_app_id_aliyun[] PROGMEM = "";           
//在此填入阿里云平台创建应用的API_KEY
const char TTS_model_uesr_app_id_volcengine[] PROGMEM = "";             //在此填入火山引擎平台创建应用的app_id
const char TTS_model_uesr_access_token_volcengine[] PROGMEM = "";    
//在此填入火山引擎平台创建应用的access_token
```



3. **程序下载**

(1) 将Arduino UNO开发板通过数据线连接至电脑。

(2) 打开本文档路径下的**“附录\04  Arduino程序文件\01 MCP工具使用\WonderLLM_example”**程序文件。

<img src="../_static/media/chapter_2/section_3/media/image1.png" style="width:500px"  class="common_img" />

(3) 开发板选择Arduino UNO，并选择正确的端口号。

<img src="../_static/media/chapter_2/section_3/media/image2.png" style="width:500px"  class="common_img" />

(4) 点击<img src="../_static/media/chapter_2/section_3/media/image3.png" style="width:40px" />，将程序下载至开发板中，等待下载完成即可。

<img src="../_static/media/chapter_2/section_3/media/image4.png" style="width:500px"  class="common_img" />

<img src="../_static/media/chapter_2/section_3/media/image5.png" style="width:500px"  class="common_img" />



3. 测试案例

本例程分别调用阿里云、火山引擎平台的音色，合成播报各语种版本的“**你好，请问有什么可以帮到你的？**”。

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 12%" />
<col style="width: 52%" />
<col style="width: 28%" />
</colgroup>
<tbody>
<tr>
<td>顺序</td>
<td>所属平台</td>
<td>音色ID</td>
<td>语种</td>
</tr>
<tr>
<td>1</td>
<td>阿里云</td>
<td>loongkyong_v2</td>
<td>韩语</td>
</tr>
<tr>
<td>2</td>
<td>阿里云</td>
<td>loongtomoka_v2</td>
<td>日语</td>
</tr>
<tr>
<td>3</td>
<td>阿里云</td>
<td>longjiayi_v2</td>
<td>粤语</td>
</tr>
<tr>
<td>4</td>
<td>火山引擎</td>
<td>zh_female_shuangkuaisisi_emo_v2_mars_bigtts</td>
<td>英语</td>
</tr>
<tr>
<td>5</td>
<td>火山引擎</td>
<td>zh_male_guangxiyuanzhou_moon_bigtts</td>
<td>国语</td>
</tr>
<tr>
<td>6</td>
<td>火山引擎</td>
<td>zh_female_yuanqinvyou_moon_bigtts</td>
<td>国语</td>
</tr>
</tbody>
</table>



4. 程序简要分析

(1) 导入WonderLLM模块库WonderLLM.h用于与模块交互。

```c
#include "WonderLLM.h"
```

(2) 定义调用TTS功能所需的用户信息。

```c
const char TTS_model_uesr_app_id_aliyun[] PROGMEM = "";           
//在此填入阿里云平台创建应用的API_KEY
const char TTS_model_uesr_app_id_volcengine[] PROGMEM = "";             //在此填入火山引擎平台创建应用的app_id
const char TTS_model_uesr_access_token_volcengine[] PROGMEM = "";   
//在此填入火山引擎平台创建应用的access_token
```

(3) 定义用于测试TTS语音合成功能的函数`TTS_function_test()`，其中根据state取值在不同的分支中使用不同的音色。进入函数首先检查WonderLLM_hiwonder对象的TTS_finish_status（**语音合成播报完毕**）成员，仅当其为真时才执行内部内容，避免当前模块正在播报的语音被主控新发来的TTS指令打断。

```c
bool TTS_function_test(){
  static char state = 1;
  if(WonderLLM_hiwonder.TTS_finish_status){
```

(4) 在每个分支中，依次调用一个音色播报测试语句。这里以分支1为例：其中依次执行指定语音模型、上传该模型平台的用户配置、指定语音合成所需音色、调用TTS服务合成测试字符串4步。`WonderLLM_Request_voice`函数调用后，TTS_finish_status成员置False。

```c
    switch(state){
      case 1:{
        //step 1-指定语音模型
        WonderLLM_hiwonder.model_ID = 1; //阿里云
        WonderLLM_set_TTS_model(&WonderLLM_hiwonder);
        osDelay(1000);
        //step 2-上传用户配置
        WonderLLM_set_TTS_AppID(&WonderLLM_hiwonder, TTS_model_uesr_app_id_aliyun); 
        //step 3-指定使用音色
        WonderLLM_set_TTS_spokesperson(spokesperson_han_yu_nv); //韩语女 
        osDelay(1000);
        //step 4-调用TTS服务 
        WonderLLM_Request_voice(&WonderLLM_hiwonder, TTS_prompt_Korean); //韩语（你好，有什么可以帮到你的）
        osDelay(1000);        
       
        state++;
        break;
      }
```

(5) 在state没有移动到最后一个分支/TTS_finish_status成员不为真时，函数返回False；仅当state移动到最后一个分支后，且TTS_finish_status成员为真时（**调用了最后一个分支的TTS指令且在模块播报完毕**），函数返回True。

```c
      case 6:{
        //step 3-指定使用音色
        WonderLLM_set_TTS_spokesperson(spokesperson_sa_jiao_xue_mei); //撒娇学妹
        osDelay(1000);
        //step 4-调用TTS服务
        WonderLLM_Request_voice(&WonderLLM_hiwonder, TTS_prompt_Chinese); //中文（你好，有什么可以帮到你的）
        osDelay(1000); 

        state++;
        break;
      }
      default:{
        return true;
        //do nothing...
      }
    }
  }
  return false;
}
```

(6) 在`setup`函数中，调用`WonderLLM_Init`函数初始化模块，并将WonderLLM_hiwonder对象的model_ID成员设为0（**指向1个无效的模型代号**），TTS_finish_status、Vision_finish_status成员设为true（**当前已完成语音播报和视觉识别/模块未在播报和识别画面**）。

```c
WonderLLM_Init(); //初始化WonderLLM模块
WonderLLM_hiwonder.model_ID = 0;
WonderLLM_hiwonder.TTS_finish_status = true;
WonderLLM_hiwonder.Vision_finish_status = true;

printf("welcome to use hiwonder's sensor!\r\n");
```

(7) 等待18s，确保模块已完成前期配网准备并正式开始工作（模块白色滚动条消失，进入表情界面）。

```c
//延时一段时间，确保模块已经上电，并完成配网（出现表情界面）
osDelay(18000);
```

>[!note]
>
>**模块完成配网前，语音合成函数无效。用户可根据实际模块配网时长灵活调整程序中18s的延时时间。**

(8) 在循环中，根据test_state在不同的switch分支执行内容，当全部音色测试完毕，`TTS_function_test()`返回真，test_state跳转至分支2，从而避免`TTS_function_test()`被多次执行。

```c
void loop() {
  static uint8_t test_state = 1;

  switch(test_state) {
    case 1:{
      if(TTS_function_test()){
        test_state ++;        
      }
      break;
    }

    default:{
      break;
    }
  }
```

(9) 调用`WonderLLM_Info_Get`函数，读取实时从IIC总线接收解析的WonderLLM数据，并转存至WonderLLM_hiwonder。

```c
//获取WonderLLM数据
WonderLLM_Info_Get(&WonderLLM_hiwonder);
```

(10) 程序根据数据类型Frame_mode执行不同的处理逻辑，在Frame_tts_finish中，当主控收到模块发来该类型消息，表明当前语音合成字符串已播报完毕，将TTS_finish_status成员置true，可以准备发送下一个字符串合成语音。

```c
switch(WonderLLM_hiwonder.Frame_mode){

    case Frame_vision_analysis:{
        //打印json原数据即可，不做其他处理

        //将IIC速率降至100W
        /*执行非必要，如果其他IIC设备均支持400W速率通信，则可不必切换回
          较低的100W，执行该函数是出于兼容其他低速IIC设备的考虑*/
        IIC_Config_normal_Transmit();	
        WonderLLM_hiwonder.Vision_finish_status = true;
        break;
    }

    case Frame_tts_finish:{
        //打印json原数据即可，不做其他处理
        //将IIC速率降至100W
        /*执行非必要，如果其他IIC设备均支持400W速率通信，则可不必切换回
            较低的100W，执行该函数是出于兼容其他低速IIC设备的考虑*/
        IIC_Config_normal_Transmit();	
        WonderLLM_hiwonder.TTS_finish_status = true;
        break;
    }
```



## **2.4STM32开发**

### 2.4.1 MCP工具使用

* #### MCP工具使用程序说明

>[!note]
>**在学习本节例程前，请确保已完成[“2.1 WonderLLM通信协议”](#anther2.1)的学习。**

1. 接线说明

接线时，WonderLLM的5V、GND、SCL和SDA引脚需与STM32开发板(此处以我司开发板Ros Robot Controller v1.2为例)进行连接，接线方式如下图所示：

<img src="..\_static\media\chapter_2\section_4\media/image14.png" style="width:600px"  class="common_img" />


>[!note]
>**通电前确保不要有金属物体接触到主板，否则可能会因主板底部的引脚导致电路短路从而烧毁主板。**



2. 程序下载

(1) 使用Type-C线插入stm32主控板的type-c口(只能插在UART1接口，如下图所示)，并且与电脑的USB口连接：

<img src="..\_static\media\chapter_2\section_4\media/image1.png" style="width:500px"  class="common_img" />

(2) 打开电脑设备管理器，在端口中查看串口号：

<img src="..\_static\media\chapter_2\section_4\media/image2.png" style="width:500px"  class="common_img" />

(3) 打开**ATX-XISP**软件，选择对应串口号，并且选择波特率为115200：

<img src="..\_static\media\chapter_2\section_4\media/image3.png" style="width:600px"  class="common_img" />

(4) 按照下图进行配置：

<img src="..\_static\media\chapter_2\section_4\media/image4.png" style="width:500px"  class="common_img" />

(5) 在软件界面点击“**文件**”按钮，选择“**附录\05 STM32程序文件\01 MCP工具使用\RosRobotControllerM4-armclang\MDK-ARM\RosRobotControllerM4\RosRobotControllerM4.hex**”文件进行烧录:

<img src="..\_static\media\chapter_2\section_4\media/image5.png" style="width:500px"  class="common_img" />

(6) 在页面中点击**“开始编程”**按钮，将生成好的hex文件烧录到stm32主控板上，等待烧录成功即可。

<img src="..\_static\media\chapter_2\section_4\media/image6.png" style="width:500px"  class="common_img" />



3. 测试案例

本例程以WonderLLM模块车机交互解决方案为例，在WonderLLM基础人机交互功能以外，向模块注册自定义MCP工具，实现若干小车控制功能。在WonderLLM进入聊天模式后，可参照以下调用示例控制模块使用对应MCP功能。

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 12%" />
<col style="width: 52%" />
<col style="width: 28%" />
</colgroup>
<tbody>
<tr>
<td>序号</td>
<td>MCP工具名</td>
<td>说明</td>
<td>调用示例</td>
</tr>
<tr>
<td>1</td>
<td>蜂鸣器控制</td>
<td>控制小车的蜂鸣器时调用这个工具。'count'是蜂鸣器响的次数</td>
<td>控制蜂鸣器响5声</td>
</tr>
<tr>
<td>2</td>
<td>LED灯控制</td>
<td>设置左右RGB灯颜色。lr,lg,lb是左灯RGB, rr,rg,rb是右灯RGB, 范围0-255</td>
<td><p>①控制左侧RGB灯亮纯绿色</p>
<p>②控制两侧RGB灯红光亮度0，绿光亮度255，蓝光亮度255</p></td>
</tr>
<tr>
<td>3</td>
<td>运动模式控制</td>
<td><p>切换小车的模式时调用这个工具。'distance'只在避障模式下使用。"</p>
<p>"可切换的模式包括：'avoid', 'line_patrol','smart_line_patrol','normal'</p></td>
<td><p>①小车进入避障模式，前方50cm内检测到障碍物自动避开</p>
<p>②小车进入巡线模式</p></td>
</tr>
<tr>
<td>4</td>
<td>状态查询</td>
<td><p>获取小车的实时状态时调用这个工具。"</p>
<p>"可查询的状态包括：'battery', 'angle', 'distance', 'running_mode'</p></td>
<td><p>①查询小车当前运动状态</p>
<p>②查询小车当前电量</p></td>
</tr>
<tr>
<td>5</td>
<td>转向控制</td>
<td>控制小车原地旋转时调用这个工具。direction参数控制方向，'left'或'right'。angle参数控制旋转的角度，单位是度(°)</td>
<td>小车左转15度</td>
</tr>
<tr>
<td>6</td>
<td>行进控制</td>
<td>控制小车移动时调用这个工具。move参数控制前后运动方向，'forward'或'backward'。distance参数控制距离，单位是厘米(cm)</td>
<td>小车前进50厘米</td>
</tr>
</tbody>
</table>


4. 实现效果

>[!note]
>
>* **串口调试助手接入开发板UART1接口**
>
>* **打开串口调试助手，波特率选择115200，编码格式选择UTF-8**

上电工作后，STM32主控会自行完成MCP工具注册，在WonderLLM模块正式开始工作后调用一次视觉识别功能识别当前环境，最后轮询检测用户语音交互调用自定义MCP工具后WonderLLM回传的数据。

<img src="..\_static\media\chapter_2\section_4\media/image16.png" style="width:700px"  class="common_img" />

以行进控制功能为例，用户可在WonderLLM进入聊天模式时，说出“小车前进50厘米”调用对应功能，WonderLLM“行进控制”工具激活后，通过IIC总线回传指令（JSON格式），STM32主控接收到后会自行解析并执行。

<img src="..\_static\media\chapter_2\section_4\media/image15.png" style="width:700px"  class="common_img" />



5. 程序简要分析

>[!note]
>
>* **模块库函数文件分为WonderLLM、WonderLLM_porting两类文件，WonderLLM_porting为主控实现模块交互底层的硬件库函数适配代码，WonderLLM为主控与模块交互读取数据的逻辑层代码。**
>
>* **在使用Keil MDK打开源码工程时，请先将Keil MDK中的编码格式设置为UTF-8，具体操作如下图：**
>
>  <img src="..\_static\media\chapter_2\section_4\media/image17.png" style="width:800px"  class="common_img" />

**5.1 app.c文件**

>[!note]
>* **WonderLLM模块STM32例程运行FreeRTOS系统，开放app_task任务供用户执行自定义逻辑，main.c仅用于初始化系统外设及开启RTOS系统，我们将调用WonderLLM模块有关的逻辑放置于app_task任务回调函数app_task_entry（位于app.c）内。**

① 导入WonderLLM模块库WonderLLM.h用于与模块交互。

```c
#include "WonderLLM.h"
```

② 在`app_task_entry`函数中，声明存储模块回传MCP指令解析结果的外部变量WonderLLM_hiwonder、用于串口输出解析结果的数组params_str。

```c
extern WonderLLM_Info WonderLLM_hiwonder;
char params_str[128] = {0};
```

③ 等待2s，确保WonderLLM模块内部IIC底层硬件配置已完成。

```c
/*WonderLLM模块上电后:
        1.需要在模块白色滚动条加载完成前，即配网工作完成前，必须调用WonderLLM_Init()将MCP工具以json格式发往模
      块完成注册，联网完成后向模块注册的MCP指令无效，因此该函数不可过晚执行
        2.WonderLLM上电后，内部也需要一定时间进行配置，不建议上电后立刻调用WonderLLM_Init发送，可能导致注册
            失败，系统整体上电后1-2s后调用WonderLLM_Init发送即可
*/
osDelay(2000);	
```

④ 调用`WonderLLM_Init`函数初始化模块，在内部先扫描检测WonderLLM是否已接入IIC总线。若是则将总线速率提升至400K并将MCP提示字符串(prompt)依次发送到模块，完成自定义MCP工具的注册；若不是则持续扫描等待，超过5秒仍未找到则判定初始化失败并退出。

```c
WonderLLM_Init(); //初始化WonderLLM模块	
printf("welcome to use hiwonder's sensor!\r\n");
```

⑤ 等待18s，确保模块已完成前期配网准备并正式开始工作（模块白色滚动条消失，进入表情界面），调用`WonderLLM_Request_Vision`视觉识别功能（即摄像头模式的场景理解功能）并传入对应的提示字符串。

```c
//调用一次模块视觉识别功能
//WonderLLM_Request_Vision传入的提示符字符串内部不能包含双引号，否则会导致解析失败
osDelay(18000);

//示例1：有参数返回
//WonderLLM_Request_Vision("识别前方画面中有什么路标，并且返回路标的名称,'letf'、'right'、‘stop’");
//示例2：无参数返回
WonderLLM_Request_Vision("识别前方画面，并结合画面内容以\'你好世界，此时我的眼前是...\'造句");
```

>[!note]
>
>* 模块完成配网前，调用该函数无效。用户可根据实际模块配网时长灵活调整程序中18s的延时时间。
>* 字符串可由用户自由组织语言，支持中/英文输入。请确保表意简洁，突出识别目的及返回内容。

⑥ 调用`WonderLLM_Info_Get`函数，读取实时从IIC总线接收解析的WonderLLM数据，并转存至WonderLLM_hiwonder。

```c
for(;;) {

        //获取WonderLLM数据
        WonderLLM_Info_Get(&WonderLLM_hiwonder);
```

⑦ 检测WonderLLM_hiwonder存放数据类型的Frame_mode成员，若等于Frame_NULL，说明没有获取到有效数据，程序延时一段时间后开始下一轮循环。反之说明获取到了有效的WonderLLM回传数据，首先将json_data_raw成员存储的回传的原始数据串口打印输出，随后清空该空间用于下一次接收。

```c
if(WonderLLM_hiwonder.Frame_mode != Frame_NULL){

        printf("raw str:%s\r\n",WonderLLM_hiwonder.json_data_raw);
        memset(WonderLLM_hiwonder.json_data_raw,0,sizeof(WonderLLM_hiwonder.json_data_raw));
```

⑧ 程序根据数据类型Frame_mode执行不同的处理逻辑，在Frame_move中，该类型字符串包含参数distance，在解析中将该项数据存放至motion_target_distance。将其打印并传入用户运动控制API（如有），最后调用`WonderLLM_Send_Action_Finish`回复WonderLLM，该MCP操作已执行完成。

```c
switch(WonderLLM_hiwonder.Frame_mode){
    case Frame_move:{
        printf("Frame_move:diatance:%d\r\n",WonderLLM_hiwonder.motion_target_distance);

        /* 执行用户自定义运动控制API */

        //该类MCP工具阻塞式执行（block=true），执行完毕需调用基础系统指令action_finish回复WinderMind
        WonderLLM_Send_Action_Finish();							
        break;
    }
```

⑨ 在Frame_get_status_battery中，需要向模块回传指定数据，将电压数据按JSON格式封装为JSON字符串，最后调用WonderLLM_Send_Status从IIC发出。
>[!note]
>**回复内容客户可自行组织，大模型会自行完成语义理解，用户仅需保证：①说明参数名称 ②注明数值、单位防止误读 ③符合JSON格式 即可。**

```c
case Frame_get_status_battery:{
  //此处假定系统电压为7.4v，实际应用时应将voltage用于承接用户提供的获取电压API的返回值
  float voltage = 7.4f;
	char temp[32];
sprintf(temp, "[\"battery\",\"%.1f\",\"V\"],", voltage);
memset(params_str,0,sizeof(params_str));
strcat(params_str, temp);

    if (strlen(params_str) > 0) params_str[strlen(params_str) - 1] = '\0';
    //该类MCP工具需返回参数给WonderLLM（return=true），执行完毕需调用基础系统指令status按指定格式回传参数
    WonderLLM_Send_Status(params_str);
    break;
}
```

⑩ 其他类型数据处理逻辑与上文高度相似，此处不再过多说明。



### 2.4.2 TTS语音合成功能

* #### **TTS语音合成功能程序说明**

>[!note]
>**在学习本节例程前，请确保已完成[“2.1 WonderLLM通信协议”](#anther2.1)的学习。**

1. 接线说明

接线时，WonderLLM的5V、GND、SCL和SDA引脚需与STM32开发板进行连接，接线方式如下图所示：

<img src="..\_static\media\chapter_2\section_4\media/image14.png" style="width:600px"  class="common_img" />



>[!note]
>**注意：通电前确保不要有金属物体接触到主板，否则可能会因主板底部的引脚导致电路短路从而烧毁主板。**



2. 准备工作

(1) 打开“**附录\05 STM32程序文件\01 MCP工具使用RosRobotControllerM4-armclang\Hiwonder\System\app.c**”,将前文配置在线语音大模型平台得到的用户信息填入如下代码，点击保存关闭。

```c
const char TTS_model_uesr_app_id_aliyun[] = "";           
//在此填入阿里云平台创建应用的API_KEY
const char TTS_model_uesr_app_id_volcengine[] = "";                     //在此填入火山引擎平台创建应用的app_id
const char TTS_model_uesr_access_token_volcengine[] = "";    
//在此填入火山引擎平台创建应用的access_token
```



3. 程序下载

(1) 使用Type-C线插入stm32主控板的type-c口(只能插在UART1接口，如下图所示)，并且与电脑的USB口连接：

<img src="..\_static\media\chapter_2\section_4\media/image1.png" style="width:500px"  class="common_img" />

(2) 打开电脑设备管理器，在端口中查看串口号：

<img src="..\_static\media\chapter_2\section_4\media/image2.png" style="width:500px"  class="common_img" />

(3) 打开**ATX-XISP**软件，选择对应串口号，并且选择波特率为115200：

<img src="..\_static\media\chapter_2\section_4\media/image3.png" style="width:600px"  class="common_img" />

(4) 按照下图进行配置：

<img src="..\_static\media\chapter_2\section_4\media/image4.png" style="width:500px"  class="common_img" />

(5) 在软件界面点击“**文件**”按钮，选择“**附录\05 STM32程序文件\01 MCP工具使用\RosRobotControllerM4-armclang\MDK-ARM\RosRobotControllerM4\RosRobotControllerM4.hex**”文件进行烧录:

<img src="..\_static\media\chapter_2\section_4\media/image5.png" style="width:500px"  class="common_img" />

(6) 在页面中点击**“开始编程”**按钮，将生成好的hex文件烧录到stm32主控板上，等待烧录成功即可。

<img src="..\_static\media\chapter_2\section_4\media/image6.png" style="width:500px"  class="common_img" />



3. 测试案例

本例程分别调用阿里云、火山引擎平台的音色，合成播报各语种版本的“**你好，请问有什么可以帮到你的？**”。

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 12%" />
<col style="width: 52%" />
<col style="width: 28%" />
</colgroup>
<tbody>
<tr>
<td>顺序</td>
<td>所属平台</td>
<td>音色ID</td>
<td>语种</td>
</tr>
<tr>
<td>1</td>
<td>阿里云</td>
<td>loongkyong_v2</td>
<td>韩语</td>
</tr>
<tr>
<td>2</td>
<td>阿里云</td>
<td>loongtomoka_v2</td>
<td>日语</td>
</tr>
<tr>
<td>3</td>
<td>阿里云</td>
<td>longjiayi_v2</td>
<td>粤语</td>
</tr>
<tr>
<td>4</td>
<td>火山引擎</td>
<td>zh_female_shuangkuaisisi_emo_v2_mars_bigtts</td>
<td>英语</td>
</tr>
<tr>
<td>5</td>
<td>火山引擎</td>
<td>zh_male_guangxiyuanzhou_moon_bigtts</td>
<td>国语</td>
</tr>
<tr>
<td>6</td>
<td>火山引擎</td>
<td>zh_female_yuanqinvyou_moon_bigtts</td>
<td>国语</td>
</tr>
</tbody>
</table>



4. 程序简要分析

>[!note]
>
>* **模块库函数文件分为WonderLLM、WonderLLM_porting两类文件，WonderLLM_porting为主控实现模块交互底层的硬件库函数适配代码，WonderLLM为主控与模块交互读取数据的逻辑层代码。**
>
>* **在使用Keil MDK打开源码工程时，请先将Keil MDK中的编码格式设置为UTF-8，具体操作如下图：**
>
>  <img src="..\_static\media\chapter_2\section_4\media/image17.png" style="width:800px"  class="common_img" />

(1) app.c文件

>[!note]
>**WonderLLM模块STM32例程运行FreeRTOS系统，开放app_task任务供用户执行自定义逻辑，main.c仅用于初始化系统外设及开启RTOS系统，我们将调用WonderLLM模块有关的逻辑放置于app_task任务回调函数app_task_entry（位于app.c）内。**

① 导入WonderLLM模块库WonderLLM.h用于与模块交互。

```c
#include "WonderLLM.h"
```

② 依次定义调用TTS功能所需的用户信息、待合成字符串、合成音色ID。

```c
const char TTS_model_uesr_app_id_aliyun[] = "";           
//在此填入阿里云平台创建应用的API_KEY
const char TTS_model_uesr_app_id_volcengine[] = "";                     //在此填入火山引擎平台创建应用的app_id
const char TTS_model_uesr_access_token_volcengine[] = "";    
//在此填入火山引擎平台创建应用的access_token

const char TTS_prompt_Chinese[] = "你好，有什么可以帮到你的?";  //中文-普通话
const char TTS_prompt_Chinese_Cantonese[] = "你好，有咩可以幫到你嘅?";   //中文-粤语
const char TTS_prompt_Japanese[] = "こんにちは。何かご用でしょうか?";  //日文
const char TTS_prompt_Korean[] = "안녕하세요. 무엇을 도와드릴까요?";   //韩文
const char TTS_prompt_English[] = "Hi, how can I help you?";      //英文

//火山引擎所属音色
const char spokesperson_zhong_ying_nv[] = "zh_female_shuangkuaisisi_emo_v2_mars_bigtts"; //中英女
const char spokesperson_guang_xi_yuan_zhou[] = "zh_male_guangxiyuanzhou_moon_bigtts";    //广西远舟
const char spokesperson_sa_jiao_xue_mei[] = "zh_female_yuanqinvyou_moon_bigtts";         //撒娇学妹

//阿里云所属音色
const char spokesperson_han_yu_nv[] = "loongkyong_v2";    //韩语女
const char spokesperson_ri_yu_nv[] = "loongtomoka_v2";    //日语女
const char spokesperson_yue_yin_nv[] = "longjiayi_v2";    //粤英女
```

③ 定义用于测试TTS语音合成功能的函数`TTS_function_test()`，其中根据state取值在不同的分支中使用不同的音色。进入函数首先检查WonderLLM_hiwonder对象的TTS_finish_status（**语音合成播报完毕**）成员，仅当其为真时才执行内部内容，避免当前模块正在播报的语音被主控新发来的TTS指令打断。

```c
bool TTS_function_test(){
  static char state = 1;
  if(WonderLLM_hiwonder.TTS_finish_status){
```

④ 在每个分支中，依次调用一个音色播报测试语句。这里以分支1为例：其中依次执行指定语音模型、上传该模型平台的用户配置、指定语音合成所需音色、调用TTS服务合成测试字符串4步。`WonderLLM_Request_voice`函数调用后，TTS_finish_status成员置False。

```c
    switch(state){
      case 1:{
        //step 1-指定语音模型
        WonderLLM_hiwonder.model_ID = 1; //阿里云
        WonderLLM_set_TTS_model(&WonderLLM_hiwonder);
        osDelay(1000);
        //step 2-上传用户配置
        WonderLLM_set_TTS_AppID(&WonderLLM_hiwonder, TTS_model_uesr_app_id_aliyun); 
        //step 3-指定使用音色
        WonderLLM_set_TTS_spokesperson(spokesperson_han_yu_nv); //韩语女 
        osDelay(1000);
        //step 4-调用TTS服务 
        WonderLLM_Request_voice(&WonderLLM_hiwonder, TTS_prompt_Korean); //韩语（你好，有什么可以帮到你的）
        osDelay(1000);        
       
        state++;
        break;
      }
```

⑤ 在state没有移动到最后一个分支/TTS_finish_status成员不为真时，函数返回False；仅当state移动到最后一个分支后，且TTS_finish_status成员为真时（**调用了最后一个分支的TTS指令且在模块播报完毕**），函数返回True。

```c
      case 6:{
        //step 3-指定使用音色
        WonderLLM_set_TTS_spokesperson(spokesperson_sa_jiao_xue_mei); //撒娇学妹
        osDelay(1000);
        //step 4-调用TTS服务
        WonderLLM_Request_voice(&WonderLLM_hiwonder, TTS_prompt_Chinese); //中文（你好，有什么可以帮到你的）
        osDelay(1000); 

        state++;
        break;
      }
      default:{
        return true;
        //do nothing...
      }
    }
  }
  return false;
}
```

⑥ 在`app_task_entry`函数中，调用`WonderLLM_Init`函数初始化模块，并将WonderLLM_hiwonder对象的model_ID成员设为0（**指向1个无效的模型代号**），TTS_finish_status、Vision_finish_status成员设为true（**当前已完成语音播报和视觉识别/模块未在播报和识别画面**）。

```c
WonderLLM_Init(); //初始化WonderLLM模块
WonderLLM_hiwonder.model_ID = 0;
WonderLLM_hiwonder.TTS_finish_status = true;
WonderLLM_hiwonder.Vision_finish_status = true;

printf("welcome to use hiwonder's sensor!\r\n");
```

⑦ 等待18s，确保模块已完成前期配网准备并正式开始工作（模块白色滚动条消失，进入表情界面）。

```c
//延时一段时间，确保模块已经上电，并完成配网（出现表情界面）
osDelay(18000);
```

>[!note]
>
>**模块完成配网前，语音合成函数无效。用户可根据实际模块配网时长灵活调整程序中18s的延时时间。**

⑧ 在循环中，根据test_state在不同的switch分支执行内容，当全部音色测试完毕，`TTS_function_test()`返回真，test_state跳转至分支2，从而避免`TTS_function_test()`被多次执行。

```c
    for(;;) {
			
			static uint8_t test_state = 1;

			switch(test_state) {
				case 1:{
					if(TTS_function_test()){
						test_state ++;        
					}
					break;
				}

				default:{
					break;
				}
			}
```

⑨ 调用`WonderLLM_Info_Get`函数，读取实时从IIC总线接收解析的WonderLLM数据，并转存至WonderLLM_hiwonder。

```c
//获取WonderLLM数据
WonderLLM_Info_Get(&WonderLLM_hiwonder);
```

⑩ 程序根据数据类型Frame_mode执行不同的处理逻辑，在Frame_tts_finish中，当主控收到模块发来该类型消息，表明当前语音合成字符串已播报完毕，将TTS_finish_status成员置true，可以准备发送下一个字符串合成语音。

```c
switch(WonderLLM_hiwonder.Frame_mode){

    case Frame_vision_analysis:{
        //打印json原数据即可，不做其他处理

        //将IIC速率降至100W
        /*执行非必要，如果其他IIC设备均支持400W速率通信，则可不必切换回
          较低的100W，执行该函数是出于兼容其他低速IIC设备的考虑*/
        IIC_Config_normal_Transmit();	
        WonderLLM_hiwonder.Vision_finish_status = true;
        break;
    }

    case Frame_tts_finish:{
        //打印json原数据即可，不做其他处理
        //将IIC速率降至100W
        /*执行非必要，如果其他IIC设备均支持400W速率通信，则可不必切换回
            较低的100W，执行该函数是出于兼容其他低速IIC设备的考虑*/
        IIC_Config_normal_Transmit();	
        WonderLLM_hiwonder.TTS_finish_status = true;
        break;
    }
```



## **2.5 micro:bit开发**

>[!note]
>**micro:bit主控暂不支持TTS语音合成功能调用**



### 2.5.1 WonderLLM库文件介绍

* #### 操作类代码块介绍

1. **设置MCP工具调用（只支持英文）**

(1)在模块上电后，调用该类型代码块向WonderLLM模块注册用户自定义的MCP工具。下文以1个例子说明：

<img src="..\_static\media\chapter_2\section_5\media/image19.png" style="width:500px"  class="common_img" /> 

<table border="1">
  <tr>
    <th colspan="3">属性参数</th>
  </tr>
  <tr>
    <th>选项</th>
    <th>参数</th>
    <th>说明</th>
  </tr>
  <tr>
    <td>工具名称</td>
    <td>self.sensor.get_status</td>
    <td>该 MCP 工具可以获取一些状态参数</td>
  </tr>
  <tr>
    <td>工具描述</td>
    <td>Call this tool when you want to get the status of the sensor. return can only battery,brightness,temperature,humidity,soil_moisture,rainwater,distance.a rainwater value of 0-400 indicates no rain, 400-1000 indicates rain, and a soil_moisture value of 0-400 indicates dryness, 400-800 indicates wetness, and 800-950 indicates complete immersion in water, brightness below 50 indicates night, otherwise it indicates day, can get distance by ultrasonic sensor.</td>
    <td>Microbit 可返回的数据类型有:电池电量、亮度(低于50表示夜间，否则表示白天)、温度、湿度、土壤湿度(0-400 表示干枯,400-800 表示潮湿,800-950 表示完全浸水)、雨水值 (0-400 表示无雨,400-1000 表示有雨)、距离。</td>
  </tr>
  <tr>
    <td>AIModule 返回参数</td>
    <td>[["get_status","string"]]</td>
    <td>WonderLLM 若执行该类MCP命令，需按此格式组织命令下发至microbit的IIC接口。(string 表示此处由 WonderLLM填入string类型变量;比如模块需获取距离，此处可填"distance")</td>
  </tr>
  <tr>
    <td>阻塞直到工具调用完成</td>
    <td>true</td>
    <td>模块下发MCP指令后，会阻塞自身工作等待microbit发送该MCP指令执行完成的回复</td>
  </tr>
  <tr>
    <td>有数据返回给AIModule</td>
    <td>true</td>
    <td>模块下发MCP指令后，会阻塞自身工作等待microbit发送该MCP指令所需的数据</td>
  </tr>
</table>

<table>
  <tr>
    <td colspan="4">使用示例</td>
  </tr>
  <tr>
    <th>序号</th>
    <th>用户交互语句</th>
    <th>模块下发命令</th>
    <th>Microbit回复（仅含 params 项）</th>
  </tr>
  <tr>
    <td>1</td>
    <td>"帮我查询一下 当前传感器采集 到的电量"</td>
    <td>[["get_status", "battery"]]</td>
    <td>[["battery", "7400mv"]]</td>
  </tr>
  <tr>
    <td>2</td>
    <td>"请问当前屋外 是否下雨了"</td>
    <td>[["get_status", "rainwater"]]</td>
    <td>[["rainwater", "815"]]</td>
  </tr>
</table>

>[!note]
>
>* **在WonderLLM完成网络设置后（出现表情界面后），该代码块执行无效，建议用户如有需要，在程序刚开始执行时即可调用该代码块。**
>
>* **该代码块可被调用多次，向WonderLLM注册多个用户自定义MCP工具。**
>
>* **注册完所有的MCP工具（连续调用若干次该代码块）后，需要调用 ”通知AIModule完成MCP设置” 代码块通知模块对注册信息做进一步处理，见1.2。**
>
>* **主控在执行完“阻塞直到工具调用完成”选项为“true”的MCP工具后，需要调用  ”通知AIModule工具调用完成” 代码块回复模块，见1.3。**
>
>* **若  “有数据返回给AIModule” 选项为 “true” ，则该MCP指令执行完毕后需要将所需类型参数以JSON字符串回传至WonderLLM，见1.4。**
>
>* **则该MCP工具默认阻塞执行，“阻塞直到工具调用完成”选项无效（若为“true”，执行完该MCP指令无需调用 "通知AIModule工具调用完成” 代码块）**
>
>*  **“工具名称” 选项填写的命名仅支持英文且必须以 “self.” 开头。**
>
>*  **“AIModule返回参数” 选项填写的返回参数格式必须满足JSON字符串语法。**
>
>* **若在交互语句中同时包含多个参数，如“帮我查询一下当前的温度和湿度”，模块会按照出现的先后顺序，依次分别获取各个参数的数值。**

 

2. **通知AIModule完成MCP设置**

(1)通知WonderLLM主控端已经完成所有用户自定义MCP指令的注册，开始准备向小智AI平台转发注册信息，后续不再处理主控新发来的MCP工具注册信息。

<img src="..\_static\media\chapter_2\section_5\media/image20.png" style="width:500px"  class="common_img" /> 

 

3. **通知AIModule工具调用完成**

(1)Microbit主控通过IIC接口向WonderLLM模块发送其下达的MCP工具执行完成信息。
>[!note]
>**主控仅需要在执行完“阻塞直到工具调用完成”选项为“true”的MCP工具时，调用该代码块回复WonderLLM模块，模块收到回复后方才继续运行。**

<img src="..\_static\media\chapter_2\section_5\media/image21.png" style="width:500px"  class="common_img" /> 

 

4. **设置AIModule进入待命状态**

(1)调用该代码块后，主控向WonderLLM发送待机指令，模块进入休眠，等待下一次用户使用唤醒词唤醒，不再侦听用户发言。

<img src="..\_static\media\chapter_2\section_5\media/image22.png" style="width:500px"  class="common_img" /> 

 

5. **设置视觉任务**

(1)调用该代码块后，microbit主控调用WonderLLM内置的视觉识别功能，执行代码块文本框中填写的视觉识别任务。

<img src="..\_static\media\chapter_2\section_5\media/image23.png" style="width:500px"  class="common_img" /> 

<table border="1">
  <tr>
    <th colspan="3">使用示例</th>
  </tr>
  <tr>
    <th>序号</th>
    <th>视觉识别任务</th>
    <th>模块回复信息</th>
  </tr>
  <tr>
    <td>1</td>
    <td>Describe the scene you are seeing at this moment in no more than 50 words（用不超过50个词描述你此刻所看到的情景）</td>
    <td>{"vision":"画面中可见部分物体边缘，下方有模糊身影，似有人手，光线明亮，整体较为模糊不清。"}</td>
  </tr>
  <tr>
    <td>2</td>
    <td>To determine if you have seen a puppy at this moment, simply reply with 'true' or 'false'.（判断你此时是否看到了小狗，只回复"true"或"false"）</td>
    <td>{"vision":"false"}</td>
  </tr>
</table>

>[!note]
>
>* **文本框中填写的视觉识别任务中不允许含有双引号和反双引号（如有请使用单引号替代），否则会导致WonderLLM解析失败。**
>* **"模块回复信息" 满足JSON字符串语法。**

 

6. **返回数据给AIModule**

(1)调用该代码块后，Microbit主控通过IIC接口向WonderLLM模块发送代码块文本框中填写的数据。
>[!note]
>
>* **主控仅需要在执行完 “有数据返回给AIModule” 选项为“true”的MCP工具时，调用该代码块将模块所需的数据上传至WonderLLM模块，模块收到回复后方才继续运行。**
>* **文本框填写的返回参数格式必须满足JSON字符串语法。**

<img src="..\_static\media\chapter_2\section_5\media/image24.png" style="width:500px"  class="common_img" /> 

 

* #### **数据类代码块介绍**

1. **获取AIModule被调用工具返回参数**

(1)检测IIC接口是否有模块发来的信息，如有则转存至该数据类代码块，任何由WonderLLM下发至microbit的信息均通过该代码块接收。
>[!note]
>**该代码块每一次被调用都会覆盖之前保存的数据，因此使用该代码块获取单次模块发来的数据后，需要及时转存避免被后续数据覆盖。**

<img src="..\_static\media\chapter_2\section_5\media/image25.png" style="width:500px"  class="common_img" /> 

 

2. **获取MCP设置参数长度（不能超过1024）**

<img src="..\_static\media\chapter_2\section_5\media/image26.png" style="width:500px"  class="common_img" />



### 2.5.2 WonderLLM 扩展包导入

1) 在编程页面点击标签选择区的**“扩展”**。

<img src="..\_static\media\chapter_2\section_5\media/image27.png" style="width:800px"  class="common_img" />) 

2) 在弹出界面中输入拓展包地址：**https://github.com/Hiwonder/IoTHouse**

3. 输入链接再单击搜索图标或按“**Enter**”键，最后单击“**iothouse**”即可成功添加。

<img src="..\_static\media\chapter_2\section_5\media/image28.png" style="width:800px"  class="common_img" /> 

4. 添加完成后将自动返回编程界面。等待加载完毕，我们可以看到程序栏已经加载了新添加的拓展包。单击“**iothouse**”标签，即可展开：

<img src="..\_static\media\chapter_2\section_5\media/image29.png" style="width:500px"  class="common_img" /> 



### 2.5.3 MCP工具使用
>[!note]
>**注意：在学习本节例程前，请确保已完成[“2.1 WonderLLM通信协议”](#anther2.1)的学习。**


1. 模块接线

<img src="..\_static\media\chapter_2\section_5\media/image1.png" style="width:800px"  class="common_img" />



2. 程序下载

(1) 将**“附录\07 microbit程序文件”**路径下的程序文件，拖入到MakeCode页面中。

<img src="..\_static\media\chapter_2\section_5\media\image3.png" style="width:800px"  class="common_img" />

(2) 点击界面左下角的<img src="..\_static\media\chapter_2\section_5\media\image4.png" style="width:0.31319in;height:0.29653in" />图标，再点击“**Connect Device**”，按照画面提示进行连接micro:bit主板。

<img src="..\_static\media\chapter_2\section_5\media\image5.png" style="width:3.14931in;height:1.05417in" />

<img src="..\_static\media\chapter_2\section_5\media\image6.png" style="width:3.14931in;height:2.91736in" />

(3) 点击左下角“**下载**”按钮进行程序烧录。

<img src="..\_static\media\chapter_2\section_5\media\image7.png" style="width:3.14931in;height:0.50347in" />

(4) 下载完成指示灯将停止快闪并保持常亮，同时编程主界面会出现下载完成提示。

<img src="..\_static\media\chapter_2\section_5\media\image8.png" style="width:3.14931in;height:0.45833in" />



3. 实现效果

(1) 用户首先需要通过唤醒词（默认为**“小幻小幻”**）唤醒WonderLLM模块。

(2) 通过与WonderLLM模块交互，用户可读取以下参数数据。例如：①**“查询当前温度”** ②**“请确认当前室外是否为雨天”**(在MCP工具描述中，将晴雨关系与雨量值关联，大模型模块会自动理解交互内容并转而读取雨量值参数)
>[!note]
>**用户可自行组织交互内容，保证内容简洁、能与MCP工具的描述直接匹配即可。**

<table border="1">
  <tr>
    <th>序号</th>
    <th>参数</th>
    <th>序号</th>
    <th>参数</th>
  </tr>
  <tr>
    <td>1</td>
    <td>电池电量battery</td>
    <td>2</td>
    <td>光照强度brightness</td>
  </tr>
  <tr>
    <td>3</td>
    <td>温度temperature</td>
    <td>4</td>
    <td>湿度humidity</td>
  </tr>
  <tr>
    <td>5</td>
    <td>土壤湿度soil_moisture</td>
    <td>6</td>
    <td>雨量rainwater</td>
  </tr>
  <tr>
    <td>7</td>
    <td>超声波测距值distance</td>
    <td></td>
    <td></td>
  </tr>
</table>



4. 程序简要分析

* **程序初始化**

1. 将用于存放**“回传至WonderLLM的JSON字符串”**的字符串变量status初始化为空字符串，初始化IoT House( 在内部完成对WonderLLM模块 IIC通信接口初始化)，将串口重定向至USB便于打印调试信息，发送“start”至电脑串口提示用户程序开始执行。

   <img src="..\_static\media\chapter_2\section_5\media\image9.png" style="width:500px"  class="common_img" />



* **按键A处理回调函数**

1. 当按键A被按下时，触发对应的回调处理函数，在内部调用执行WonderLLM视觉识别任务，在代码块中填入引导语句。

<img src="..\_static\media\chapter_2\section_5\media\image30.png" style="width:500px"  class="common_img" />



* **WonderLLM指令读取与MCP工具注册**

1.  在microbit中注册一个定时器，每20ms触发执行一次其中的逻辑。

   <img src="..\_static\media\chapter_2\section_5\media\image9_5.png" style="width:500px"  class="common_img" />

2. 每进入一次，首先尝试获取WonderLLM从IIC接口发来的单次指令字符串（若没有接收指令则为空字符串），并转存至mcp_return列表中最后一个元素。

<img src="..\_static\media\chapter_2\section_5\media\image10.png" style="width:500px"  class="common_img" />

3)  之后检查WonderLLM内部初始化完成标志位aimodule_init(默认为false)和MCP指令注册完成标志位init_finish(默认为false)。

4)  若检测到aimodule_init为true，init_finish为false，则表示当前模块完成初始化但尚未注册MCP工具，此时进一步执行内部逻辑：

>[!note]
>
**当WonderLLM模块完成初始化，会自行向microbit发送特定指令，主控接收并解析识别到后，将aimodule_init置为true，具体将在"WonderLLM指令解析与处理-3"讲解。**

<img src="..\_static\media\chapter_2\section_5\media\image10_5.png" style="width:500px"  class="common_img" />

5. 首先延时一段时间，再将init_finish置true，避免后续内部逻辑被多次执行，反复向WonderLLM注册MCP工具。

   <img src="..\_static\media\chapter_2\section_5\media\image10_5.png" style="width:500px"  class="common_img" />

6. 注册MCP指令（此处仅以1个MCP工具为例），在**“工具描述”**选项中向WonderLLM指明该MCP工具的在需要获取传感器参数时调用，提供在返回指令中**“get_status”**项string变量的可选项；在**“AIModule返回参数”**选项中指明该MCP工具返回的指令格式；

7. 在**“有数据返回AIModule”**选项中指定该MCP指令执行完毕后需要将所需类型参数以JSON字符串回传至WonderLLM。

>[!note]
>**若“有数据返回给AIModule”选项为“true”，则该MCP工具默认阻塞执行，“阻塞直到工具调用完成”选项无效（若为“true”，执行完该MCP指令无需调用”通知AIModule工具调用完成”代码块）。**

<img src="..\_static\media\chapter_2\section_5\media\image11.png" style="width:500px"  class="common_img" />

8)  查询当前WonderLLM支持的MCP设置参数长度，用于调试检查该项配置是否正确。

<img src="..\_static\media\chapter_2\section_5\media\image11_1.png" style="width:600px"  class="common_img" />

9)  全部MCP工具注册完毕后，通知WonderLLM停止接收后续MCP工具字符串并将已接收注册信息转发至小智AI平台。延时一段时间并在micro:bit的LED点阵打印**“ok”**字符串供调试。

<img src="..\_static\media\chapter_2\section_5\media\image12.png" style="width:500px"  class="common_img" />



* **WonderLLM指令解析与处理**

1. 在主循环程序中，负责解析WonderLLM指令，并根据解析结果做对应处理。首先检查存储WonderLLM发来指令字符串的列表mcp_return，若其长度不大于0，说明内部没有数据可供读取。

   <img src="..\_static\media\chapter_2\section_5\media\image13.png" style="width:500px"  class="common_img" />

3. 若mcp_return长度大于0，则取出该列表中的第一个元素（列表中该元素被同步移除，所有元素前移一位）转存至变量action，判断action是否为空字符串。若是则说明在该轮数据收取中，WonderLLM并未下发数据。

<img src="..\_static\media\chapter_2\section_5\media\image13.png" style="width:500px"  class="common_img" />

3. 若mcp_return长度大于0，且mcp_return列表中的第一个元素非空字符串，进一步匹配action内是否存在**“starting”**子字符串，仅在WonderLLM完成初始化时，会发送包含**“starting”**的指令，因此将WonderLLM内部初始化完成标志位aimodule_init置true。

<img src="..\_static\media\chapter_2\section_5\media\image14.png" style="width:500px"  class="common_img" />

4. 之后匹配action内是否存在**“vision”**子字符串，若是则说明WonderLLM调用了视觉识别系统指令。此时进一步检测MCP指令中是否包含 **“false”** 子字符串，若是则说明当前没有识别到小狗，将 **‘n’** 显示在主板LED点阵；若不是则说明当前识别到小狗，将 **‘y’** 显示在主板LED点阵。

<img src="..\_static\media\chapter_2\section_5\media\image31.png" style="width:500px"  class="common_img" />

4. 之后匹配action内是否存在**“get_status”**子字符串，若是则说明WonderLLM调用了**“self.sensor.get_status”**MCP指令。

<img src="..\_static\media\chapter_2\section_5\media\image15.png" style="width:500px"  class="common_img" />

6. 若WonderLLM调用了**“self.sensor.get_status”**MCP指令，进一步匹配action内是否存在匹配各个参数子字符串，如下图：

7. 这里以WonderLLM读取光照强度（光敏传感器值）为例，则action包含**“brightness”**子字符串，此时获取光敏传感器值，并作为参数传入combiningstrings函数，将待上传的数据拼接为JSON字符串格式。

>[!note]
>
>* **combiningstrings函数的具体工作细节详见 “上传数据JSON字符串拼接”。**
>* **经过combiningstrings函数处理后的JSON字符串转存在status变量中，此时status存储的是初步构造，还不完整的JSON字符串，在后续讲解内容中才完成JSON字符串的完整构造。**

<img src="..\_static\media\chapter_2\section_5\media\image16.png" style="width:700px"  class="common_img" />

8)  完成了对所有的参数对应的字符串的匹配，首先检测存放初步构造JSON字符串的变量status长度，若不大于0，说明之前并没有匹配到任何一个参数对应的字符串，无需执行内部完善JSON字符串的逻辑。

9)  若status长度大于0，则将status使用**“\[”**、**“\]”**包裹并重新赋值给自身，重新赋值的status即为完整构造的JSON字符串，此时可以将status返回给WonderLLM，并将status赋值为空字符串（清空），等待下一次处理**“self.sensor.get_status”**MCP指令时使用。

<img src="..\_static\media\chapter_2\section_5\media\image17.png" style="width:500px"  class="common_img" />



* **上传数据JSON字符串拼接**

1)  在combiningstring函数中，负责构造JSON字符串用于上传参数数据至WonderLLM。

2)  举例来说，当构造湿度参数JSON字符串，**cmd（数据类型）**为**“humidity”**，**sensor_data（参数数据）**为**湿度值(例如80)**，**unit（数据单位）**为**“%”**，初步构造字符串**\[”humidity”,”80** 转存至临时变量temp。

<img src="..\_static\media\chapter_2\section_5\media\image17_5.png" style="width:500px"  class="common_img" />

3)  之后检测存放初步构造JSON字符串的变量status长度，若不大于0，说明当前是向status内传入的第一种参数，在temp的基础上进一步补充JSON字符串并转存至status，例如**\[”humidity”,”80%”\]** 。

<img src="..\_static\media\chapter_2\section_5\media\image18.png" style="width:500px"  class="common_img" />

4. 若大于0，说明status内已经存放其他参数的字符串，例如**\[”battery”,”7400mv”\]**,则将本轮temp构造的字符串补充数据单位unit和分隔符 **‘,’** 后追加至status原有内容前，如：**\[”humidity”,”80%”\],\[”battery”,”7400mv”\]** 。

   <img src="..\_static\media\chapter_2\section_5\media\image18_5.png" style="width:500px"  class="common_img" />

>[!note]
>
>* **若在交互语句种同时包含多个参数，如“帮我查询一下当前的温度和湿度”，模块会按照出现的先后顺序，依次分别获取各个参数的数值。**
>
>* **因此理论上只会在一个参数的字符串与MCP命令匹配，本分支内的逻辑理论上不会被使用，在此处放置仅用于增强程序健壮性，应对可能出现的其他情况。**



* **JSON字符串关键词提取**

1) 该函数负责将一个字符串按照给定的分隔符拆解。dict参数传入原始MCP指令字符串，split1传入第一个分隔符，函数将MCP指令字符串按第一个分隔符split1分片并依次存放在第一个临时列表变量。
>[!note]
>
**举例：dict取{"light_type":"rgb","red":120,"green":120,"blue":120}，split1取‘，’(逗号) ，分片后的临时列表为[light_type":"rgb"  ,   "red":120  ,  "green":120  ,  "blue":120]。**

2) 随后，函数按传入的索引index1从临时列表取出对应的元素进一步处理。
3) 之后，函数将取出的元素按传入的第二个分隔符split2再一次分片并依次存放在第二个临时列表变量。
>[!note]
>
**举例：index1取1 ，取出临时列表的"red":120 这个元素，split2取‘:’(冒号)，第二次分片后的临时列表为["red"  ,  120]。**

4) 最后，函数按传入的索引index2从第二个临时列表取出对应的元素作为返回值传出。
>[!note]
>
**举例：index2取1 ，取出第二个临时列表的120元素。**

<img src="..\_static\media\chapter_2\section_5\media\image32.png" style="width:700px"  class="common_img" />



## **2.6小智开源程序**

### 2.6.1小智开源程序说明

* **概述**

WonderLLM模块固件基于小智开源项目进行移植并二次开发，并赋予了更多趣味功能,您可以通过超链接跳转[**GitHub - 78/xiaozhi-esp32**](https://github.com/78/xiaozhi-esp32)直接访问该开源代码仓库。

为便于用户学习源代码工程，并在此基础上自行二次开发，在我司自有固件WonderLLM.bin固件基础上，我司同时还提供仅完成移植适配WonderLLM模块的源代码工程文件及对应固件hiwonder_xiaozhi.bin，使原程序实现效果可在本模块上完整运行。



* **功能说明**

基于我司移植适配的小智开源程序及固件运行效果与源代码完全一致，但与我司二次开发固件WonderLLM.bin功能上存在一些差异，可参见下表：
>[!note]
>**除了功能上的异同，两固件运行时的UI界面也不相同。**

<table>
<tr><td>支持功能</td><td>幻尔二次开发固件WonderLLM.bin</td><td>小智官方固件hiwonder_xiaozhi.bin</td></tr>
<tr><td>自定义配网</td><td>支持</td><td>支持</td></tr>
<tr><td>语音唤醒</td><td>支持</td><td>不支持</td></tr>
<tr><td>修改唤醒词</td><td>支持</td><td>支持</td></tr>
<tr><td>天气时钟界面显示</td><td>支持</td><td>不支持</td></tr>
<tr><td>触摸屏调节音量以及亮度</td><td>支持</td><td>不支持</td></tr>
<tr><td>连续对话</td><td>支持</td><td>支持</td></tr>
</table>



* **开发环境部署**
>[!note]
>
>* **如您需要编译下载工程文件至模块，需确保您已完成乐鑫官方开发工具ESP-IDF的部署，本小节简单介绍该工具的快速部署。**
>* **为了简化安装难度，使用户可以投入更少的精力在ESP-IDF的工作依赖配置上，同时实现操作步骤在各环境的通用性，本文选择以VScode环境安装IDF插件的方式完成部署，用户需要先自行完成VScode的安装。**

1. 打开VScode，点击侧边栏的扩展功能图标，在搜索框中输入“**ESP-IDF**”。

   <img src="..\_static\media\chapter_2\section_6\media/image1.png" style="width:800px"  class="common_img" />

2. 选择“**ESP-IDF**”同名插件，点击安装。

   <img src="..\_static\media\chapter_2\section_6\media/image2.png" style="width:800px"  class="common_img" />

3. 安装完成后，可以看到侧边栏出现了该插件的扩展图标。

   <img src="..\_static\media\chapter_2\section_6\media/image3.png" style="width:800px"  class="common_img" />

4. 快捷键连击“**Ctrl+shift+P**”（或点击上方菜单栏“**查看-命令面板**”），呼出VScode命令面板，输入“**ESP-IDF Welcome**”，进入该插件的功能界面。

   <img src="..\_static\media\chapter_2\section_6\media/image4.png" style="width:800px"  class="common_img" />

5. 点击“**configure extension**”，进入该插件的部署引导子界面。

   <img src="..\_static\media\chapter_2\section_6\media/image5.png" style="width:800px"  class="common_img" />

6. 选择“**ADVANCED**”部署类型。

   <img src="..\_static\media\chapter_2\section_6\media/image6.png" style="width:800px"  class="common_img" />

7. 配置项选择可参考下图。
>[!note]
>
>* **下载服务器“Seleet download server”中国大陆用户推荐使用Espressif(乐鑫官方服务器),反之推荐github。**
>* **IDF工具及依赖“Enter ESP-IDF container directory”、“Enter ESP-IDF Tools directory (IDF TOOLS PATH)”的安装路径可由用户自定义。**

<img src="..\_static\media\chapter_2\section_6\media/image7.png" style="width:800px"  class="common_img" />

8. VScode开始自动下载ESP-IDF开发环境依赖。

   <img src="..\_static\media\chapter_2\section_6\media/image8.png" style="width:800px"  class="common_img" />

9. 当第一步完成后，VScode会出现弹窗，向用户确认IDF工具链的安装细节，这里直接点击“**Download Tools**”，点击后VScode继续第二步和第三步的下载安装。

   <img src="..\_static\media\chapter_2\section_6\media/image9.png" style="width:800px"  class="common_img" />

10. 下载完成后，VScode出现如下弹窗，至此ESP-IDF环境部署完成。

<img src="..\_static\media\chapter_2\section_6\media/image10.png" style="width:800px"  class="common_img" />



* **程序编译烧录**
>[!note]
>
>* **我司提供仅完成移植适配WonderLLM模块的源代码工程文件及对应固件，您可以分别通过编译下载工程文件、烧录固件两种方式体验源代码功能玩法。**
>* **如您选择烧录固件方式，需根据 “1. 基础课程/1.8 固件烧录”  使用对应烧录软件，将hiwonder_xiaozhi.bin(路径:“1.基础课程\附录\05  ESP32S3固件\01 官方开源固件”)按相同方式烧录至模块内即可，本文不再展开，下文具体介绍工程文件编译下载至模块的操作方式。**

1)  打开VScode，点击“**文件-打开文件夹**”。

<img src="..\_static\media\chapter_2\section_6\media/image11.png" style="width:800px"  class="common_img" />

2)  选择小智开源程序工程(路径：**附录\06 小智开源程序工程** )文件夹并打开。
>[!note]
>**若VScode出现弹窗询问是否信任该文件夹作者，请选择信任，否则ESP-IDF插件的使用会受限。**

<img src="..\_static\media\chapter_2\section_6\media/image12.png" style="width:700px"  class="common_img" />

3. 将WonderLLM接入电脑，在下方扩展栏中点击图示图标，选择设备串口。

4. 在下方扩展栏中点击图示图标，选择芯片型号为“**ESP32S3**”。

   <img src="..\_static\media\chapter_2\section_6\media/image13.png"  />

5. 在下方扩展栏中点击图示图标，自动调用ESP-IDF对当前工程依次进行构建、烧录、监视。初次构建工程需要一定时间，请您等待片刻。

   <img src="..\_static\media\chapter_2\section_6\media/image14.png" style="width:5.76181in;height:0.87431in" />

6. 当终端输出如下提示，表示工程构建成功。

<img src="..\_static\media\chapter_2\section_6\media/image15.png" style="width:700px"  class="common_img" />

7. 当终端输出如下提示，表示工程烧录成功。

<img src="..\_static\media\chapter_2\section_6\media/image16.png" style="width:700px"  class="common_img" />

8. 当终端输出如下提示，表示工程开始监视程序（日志输出）。

<img src="..\_static\media\chapter_2\section_6\media/image17.png" style="width:700px"  class="common_img" />




### 2.6.2小智开源程序工程

**路径：附录\06 小智开源程序工程**
