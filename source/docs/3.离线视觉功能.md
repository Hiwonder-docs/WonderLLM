# 3.离线视觉功能

## 3.1 Arduino开发环境搭建

### 3.1.1 Arduino IDE安装

Arduino IDE 是一款专门为 Arduino 单片机而设计的软件，功能强大。无论是哪个版本，其安装过程都是相同的，本节以 Arduino-2.2.1 的 windows 版软件为例进行讲解：

> [!NOTE]
> 
>
> **Mac版安装方法可在本节目录中查看。**

1. 在**"附录\01 WonderLLM开发环境包\01 ArduinoIDE安装包"**路径下找到ArduinoIDE的安装包，如下所示，双击打开。（若想下载最新版软件，可通过arduino官网"[**https://www.arduino.cc/en/software**](https://www.arduino.cc/en/software)"进行下载）

   <img class="common_img" src="..\_static\media\chapter_3\section_1\media\image1.png"  />

2. 点击**"我同意"**，进入安装。

<img class="common_img" src="..\_static\media\chapter_3\section_1\media\image2.png"   />

3)  选择默认勾选选项即可，点击"**下一步**"，进入下一步操作。

<img class="common_img" src="..\_static\media\chapter_3\section_1\media\image3.png"   />

4)  点击"**浏览**"选择安装的路径，然后点击"**安装**"开始安装。

<img class="common_img" src="..\_static\media\chapter_3\section_1\media\image4.png"   />

5)  等待软件安装完成。

<img class="common_img" src="..\_static\media\chapter_3\section_1\media\image5.png"   />

> [!NOTE]
>
> **安装过程如果提示需要芯片驱动的安装，请勾选"始终信任来自Arduino LLC的软件（A）"，然后点击"安装"即可。**

6)  安装完成后，点击**"完成"**。

<img class="common_img" src="..\_static\media\chapter_3\section_1\media\image6.png"   />

### 3.1.2 Arduino IDE界面分布介绍 

Arduino IDE 的主界面如下图，可分为5个区域：

<img class="common_img" src="..\_static\media\chapter_3\section_1\media\image7.png"   />

1.  **菜单栏**： 负责Arduino IDE相关设置工作。

| **图标**                                                     | **功能**                                             |
| ------------------------------------------------------------ | ---------------------------------------------------- |
| <img class="common_img" src="../_static/media/chapter_3/section_1/media\image8.png"  /> | 可以新建或打开项目文件，也可以对界面进行首选项设置   |
| <img class="common_img" src="../_static/media/chapter_3/section_1/media\image9.png"  /> | 编辑选项，可对代码进行注释、缩进、查找等文本编辑     |
| <img class="common_img" src="../_static/media/chapter_3/section_1/media\image10.png"  /> | 项目选项，对整个项目进行设置，编译运行、添加库文件等 |
| <img class="common_img" src="../_static/media/chapter_3/section_1/media\image11.png"  /> | 工具选项，可以选择开发板和端口以及获得开发板信息等   |
| <img class="common_img" src="../_static/media/chapter_3/section_1/media\image12.png"  /> | 帮助选项，帮助用户入门，常见问题解决等               |

2.  **工具栏**：项目相关的一些工具，包括编译程序、下载程序、串口监视器等工具。

| **图标**                                                     | **功能**                                            |
| ------------------------------------------------------------ | --------------------------------------------------- |
| <img class="common_img" src="../_static/media/chapter_3/section_1/media\image13.png"  /> | 校验，验证一个程序是否编写无误，若无误则编译该项目  |
| <img class="common_img" src="../_static/media/chapter_3/section_1/media\image14.png"  /> | 下载，下载程序到 Arduino 控制器上                   |
| <img class="common_img" src="../_static/media/chapter_3/section_1/media\image15.png"  /> | 调试，部分开发板可以通过Arduino IDE实时调试         |
| <img class="common_img" src="../_static/media/chapter_3/section_1/media\image16.png"  /> | 选择开发板，可以选择不同的开发板进行项目开发        |
| <img class="common_img" src="../_static/media/chapter_3/section_1/media\image17.png"  /> | 串口绘图仪，可以将打印到Arduino串口的数据绘制成图表 |
| <img class="common_img" src="../_static/media/chapter_3/section_1/media\image18.png"  /> | 串口监视器，打印串口信息                            |

3.  **编辑区**：编辑代码的区域。

4.  **状态栏**：显示当前编辑器的一些状态，例如代码的行列、开发板的信息等。

5.  **侧边栏**：Arduino IDE的核心，负责显示工作文件夹、代码调试、库文件安装等。

| **图标**                                                     | **功能**                         |
| ------------------------------------------------------------ | -------------------------------- |
| <img class="common_img" src="../_static/media/chapter_3/section_1/media\image19.png"  /> | 项目文件夹，显示当前项目的文件。 |
| <img class="common_img" src="../_static/media/chapter_3/section_1/media\image20.png"  /> | 开发板管理器，添加开发板工具包。 |
| <img class="common_img" src="../_static/media/chapter_3/section_1/media\image21.png"  /> | 库管理，添加或删除程序的库文件。 |
| <img class="common_img" src="../_static/media/chapter_3/section_1/media\image22.png"  /> | 调试，对项目实时调试。           |
| <img class="common_img" src="../_static/media/chapter_3/section_1/media\image23.png"  /> | 搜索，可搜索或替换代码或变量。   |



### 3.1.3 Arduino IDE界面设置

1. 修改中文界面：在Arduino IDE界面选择"**File**"->" **Preferences**"，在弹出的窗口中"**language**"选项栏中，选择切换为中文，随后点击"**OK**"即可。

   <img class="common_img" src="..\_static\media\chapter_3\section_1\media\image24.png" style="width:600px" />

2. 我们可以通过选择"**文件->首选项**"在弹出的窗口下修改项目文件路径、编辑器文字大小、颜色主题等设置。

   <img class="common_img" src="..\_static\media\chapter_3\section_1\media\image25.png" style="width:600px" />



### 3.1.4 ESP32固件安装

>[!note]
>
>**在进行本步骤前，需要先完成Arduino IDE软件安装**

1) 如果安装过其他版本的esp32 package且安装的版本不为2.0.12，请先参照步骤2删除。若未安装过，可直接跳转到步骤3开始安装。
2) 删除方法：文件管理器地址栏输入 **"%LOCALAPPDATA%/Arduino15/packages"**，回车进入，然后删除掉其中的esp32文件夹。 

<img class="common_img" src="..\_static\media\chapter_3\section_1\media\image34.png"  />

3. 最后双击**"附录\01 WonderLLM开发环境包\02 ESP32模块固件包"**路径下的**“esp32_package_2.0.12_arduinome.exe”**文件，等待安装完成即可。

<img class="common_img" src="..\_static\media\chapter_3\section_1\media\image35.png"  />



### 3.1.5 WonderLLM程序下载

1. 这里我们以一个打印"**hiwonder**"字样的例程为例进行说明。在**"附录\01 WonderLLM开发环境包\03_Demo"**路径下双击打开"**03_Demo.ino**"的示例程序。

   <img class="common_img" src="..\_static\media\chapter_3\section_1\media\image26.png" style="width:600px" />

2. 将ESP32核心板通过数据线连接至电脑。

   <img class="common_img" src="..\_static\media/chapter_3/section_2/media/image1.png"  width="400px" />

3. 在"**选择开发板**"选项中找到Arduino对应的开发板。（**COM口不唯一，我们可以通过电脑的设备管理中查看COM号，此处以COM6为例**）

   <img class="common_img" src="..\_static\media\chapter_3\section_1\media\image27.png" style="width:600px" />

4. 点击<img  src="..\_static\media\chapter_3\section_1\media\image28.png"  />按钮可对程序进行编译，可以验证程序是否存在语法错误等问题。

   <img class="common_img" src="..\_static\media\chapter_3\section_1\media\image29.png" style="width:600px" />

5. 编译成功后，再点击<img  src="..\_static\media\chapter_3\section_1\media\image30.png"  />按钮会将程序上传到ESP32核心板上。

   <img class="common_img" src="..\_static\media\chapter_3\section_1\media\image31.png" style="width:600px" />

6. 上传完成后，点击<img   src="..\_static\media\chapter_3\section_1\media\image32.png"  />打开串口监视器，我们可以看到在串口监视器中打印出了"**hiwonder**"字样。

   <img class="common_img" src="../_static/media/chapter_3/section_1\media\image33.png" style="width:600px" />



## 3.2 图像回传

### 3.2.1 项目说明

本节通过连接WonderLLM视觉模块产生的热点，登录固定网址查看摄像头实时回传画面。

### 3.2.2 程序下载

1. 使用Type-C线连接WonderLLM上方的Type-C接口。

   <img class="common_img" src="..\_static\media/chapter_3/section_2/media/image1.png" width="400px" />

2. 打开程序**“附录\03 WonderLLM程序\APCameraWebServer\APCameraWebServer.ino”**。

   <img class="common_img" src="..\_static\media/chapter_3/section_2/media/image2.png" />

3. 选择**“ESP32S3 Dev Module”**开发板。

<img class="common_img" src="..\_static\media/chapter_3/section_2/media/image3.png" />

4. 点击菜单栏的**“工具”**，按照下图选择相应的ESP32S3的开发板配置。

<img class="common_img" src="..\_static\media/chapter_3/section_2/media/image4.png" />

5. 最后点击<img src="..\_static\media/chapter_3/section_2/media/image5.png" />将代码下载至WonderLLM内，等待烧录完成即可。

<img class="common_img" src="..\_static\media/chapter_3/section_2/media/image6.png" />

<img class="common_img" src="..\_static\media/chapter_3/section_2/media/image7.png" />



### 3.2.3 图像回传实现

1. 程序下载完成后，连接并找到WonderLLM模块产生的热点：**HW_ESP32S3CAM** 。

<img class="common_img" src="..\_static\media/chapter_3/section_2/media/image8.png" />

2. 在浏览器网址栏（手机、PC端浏览器皆可，我们以PC端为例子）中输入**“192.168.5.1”**后回车，在打开的页面里，点击<img src="..\_static\media/chapter_3/section_2/media/image9.png" />按钮，即可进入到摄像头回传界面<img class="common_img" src="..\_static\media/chapter_3/section_2/media/image10.png" />



### 3.2.4 实现效果

通过连接WonderLLM视觉模块产生的热点，登录固定网址可查看摄像头实时回传画面。



### 3.2.5 程序分析

* **导入头文件**

```c
#include "camera_pins.h"
#include "lib/adafruit/Adafruit_GFX.h"
#include "lib/adafruit/Adafruit_ST7789.h"
#include <SPI.h>
```

引入了必要的头文件，包括摄像头驱动、WiFi、摄像头引脚定义、TFT屏幕驱动和SPI库。

* **宏定义**

```
#define TFT_CS   2
#define TFT_DC   1
#define TFT_RST -1   // 如果绑3.3V，就写 -1
#define TFT_BL  14
```

定义了TFT屏幕的引脚：片选（CS）、数据/命令（DC）、复位（RST）和背光（BL）

* **函数声明和全局变量**

```c
void tft_show_rgb565(const uint16_t *rgb565_buf, int width, int height);
void startCameraServer();

static Adafruit_ST7789 tft = Adafruit_ST7789(TFT_CS, TFT_DC, TFT_RST);
```

1. 声明了TFT显示函数和启动相机服务器的函数。

2. 创建了一个`Adafruit_ST7789`对象用于控制TFT屏幕。

* **WIFI配置**

```
const char* ssid = "HW_ESP32S3CAM";
const char* password = "";
IPAddress local_ip(192, 168, 5, 1);       // 设置自定义 IP 地址
IPAddress gateway(192, 168, 1, 1);        // 网关地址
IPAddress subnet(255, 255, 255, 0);       // 子网掩码
```

设置了WiFi AP的SSID和密码（密码为空），以及AP的IP地址、网关和子网掩码。

* **初始化设置**

1. 初始化串口,设置通信波特率为115200。

```c
void setup() 
{
  Serial.begin(115200);
  Serial.println();

```

2. 配置摄像头参数（引脚、时钟频率、分辨率、像素格式等）。

```c
  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer = LEDC_TIMER_0;
  config.pin_d0 = Y2_GPIO_NUM;
  config.pin_d1 = Y3_GPIO_NUM;
  config.pin_d2 = Y4_GPIO_NUM;
  config.pin_d3 = Y5_GPIO_NUM;
  config.pin_d4 = Y6_GPIO_NUM;
  config.pin_d5 = Y7_GPIO_NUM;
  config.pin_d6 = Y8_GPIO_NUM;
  config.pin_d7 = Y9_GPIO_NUM;
  config.pin_xclk = XCLK_GPIO_NUM;
  config.pin_pclk = PCLK_GPIO_NUM;
  config.pin_vsync = VSYNC_GPIO_NUM;
  config.pin_href = HREF_GPIO_NUM;
  config.pin_sccb_sda = SIOD_GPIO_NUM;
  config.pin_sccb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn = PWDN_GPIO_NUM;
  config.pin_reset = RESET_GPIO_NUM;
  config.xclk_freq_hz = 16000000;
  config.frame_size = FRAMESIZE_QVGA;
  config.pixel_format = PIXFORMAT_RGB565; // for streaming
  //config.pixel_format = PIXFORMAT_RGB565; // for face detection/recognition
  config.grab_mode = CAMERA_GRAB_WHEN_EMPTY;
  config.fb_location = CAMERA_FB_IN_PSRAM;
  config.jpeg_quality = 12;
  config.fb_count = 2;
```

3. 初始化摄像头。

```c
  // camera init
  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed with error 0x%x", err);
    return;
  }

  sensor_t * s = esp_camera_sensor_get();
#if defined(CAMERA_MODEL_ESP32S3_EYE)
  // s->set_vflip(s, 1);
#endif
  pinMode(TFT_BL, OUTPUT);
  digitalWrite(TFT_BL, HIGH);
```

4. 初始化SPI以及TFT屏幕。

```c
  // 初始化 SPI (必须指定SCK, MOSI引脚)
  SPI.begin(21, -1, 47);  // SCK=21, MISO=-1(不用), MOSI=47

  // 初始化屏幕（分辨率要填对）
  tft.init(240, 320);
  tft.setRotation(3);  // 旋转使坐标系为 320x240
  // 提升 SPI 时钟以提高刷新速度
  tft.setSPISpeed(80000000);
  tft.fillScreen(ST77XX_BLACK);  //填充黑色背景
```

5. 设置WiFi为AP模式，并启动AP，配置AP的IP地址。

```
  WiFi.mode(WIFI_AP);
  WiFi.softAP(ssid, password, 6, false, 4); // SSID, 密码, 信道6, 不隐藏SSID, 最大连接数4
  // WiFi.begin(ssid, password);
  WiFi.setSleep(false);
  // 配置 IP 地址
  if (!WiFi.softAPConfig(local_ip, gateway, subnet)) {
    Serial.println("Failed to configure IP");
  }
  Serial.println("WiFi AP Started");
  Serial.print("AP IP Address: ");
  Serial.println(WiFi.softAPIP()); // 输出 AP 的 IP 地址
```

* **TFT显示函数（tft_show_rgb565）**

这个函数负责将摄像头捕获的RGB565图像显示到TFT屏幕上。

1. 如果图像分辨率是240x320，而屏幕是320x240，则进行旋转和镜像处理。

```c
    if (width == 240 && height == 320 && screen_w == 320 && screen_h == 240) {
        static uint16_t *rotated = nullptr;
        static int rotated_capacity = 0;
        int rotated_pixels = screen_w * screen_h;
        if (rotated_capacity < rotated_pixels) {
            if (rotated) free(rotated);
            rotated = (uint16_t *)malloc(rotated_pixels * sizeof(uint16_t));
            rotated_capacity = rotated_pixels;
        }

        for (int y = 0; y < height; y++) {
            for (int x = 0; x < width; x++) {
                int dst_x = y;
                int dst_y = width - 1 - x;
                // **水平镜像修改**
                dst_y = screen_w - 1 - dst_y;
                rotated[dst_y * screen_w + dst_x] = work_buf[y * width + x];
            }
        }
        tft.drawRGBBitmap(0, 0, rotated, screen_w, screen_h);
        return;
    }
```

2. 如果图像分辨率与屏幕分辨率相同，则进行水平镜像后直接绘制。

```cpp
    if (width == screen_w && height == screen_h) {
        static uint16_t *mirror_buf = nullptr;
        static int mirror_capacity = 0;
        if (mirror_capacity < pixel_count) {
            if (mirror_buf) free(mirror_buf);
            mirror_buf = (uint16_t *)malloc(pixel_count * sizeof(uint16_t));
            mirror_capacity = pixel_count;
        }
        for (int y = 0; y < height; y++) {
            for (int x = 0; x < width; x++) {
                mirror_buf[y * width + x] = work_buf[y * width + (width - 1 - x)]; // 水平镜像
            }
        }
        tft.drawRGBBitmap(0, 0, mirror_buf, width, height);
        return;
    }
```

3. 其他情况则进行缩放处理（Cover模式），保持图像比例并填满屏幕，同时进行水平镜像。

```cpp
    static uint16_t *scaled = nullptr;
    static int scaled_capacity = 0;
    int scaled_pixels = screen_w * screen_h;
    if (scaled_capacity < scaled_pixels) {
        if (scaled) free(scaled);
        scaled = (uint16_t *)malloc(scaled_pixels * sizeof(uint16_t));
        scaled_capacity = scaled_pixels;
    }

    bool scale_by_width = ((int64_t)screen_w * height >= (int64_t)screen_h * width);
    if (scale_by_width) {
        int visible_src_h = (int)((int64_t)screen_h * width / screen_w);
        if (visible_src_h > height) visible_src_h = height;
        int src_y_offset = (height - visible_src_h) / 2;

        static int *y_map = nullptr;
        static int y_map_cap = 0;
        if (y_map_cap < screen_h) {
            if (y_map) free(y_map);
            y_map = (int *)malloc(screen_h * sizeof(int));
            y_map_cap = screen_h;
        }
        for (int dy = 0; dy < screen_h; dy++) {
            y_map[dy] = src_y_offset + (int)((int64_t)dy * visible_src_h / screen_h);
        }

        static int *x_map = nullptr;
        static int x_map_cap = 0;
        if (x_map_cap < screen_w) {
            if (x_map) free(x_map);
            x_map = (int *)malloc(screen_w * sizeof(int));
            x_map_cap = screen_w;
        }
        for (int dx = 0; dx < screen_w; dx++) {
            x_map[dx] = (int)((int64_t)dx * width / screen_w);
            // **水平镜像修改**
            x_map[dx] = width - 1 - x_map[dx];
        }

        for (int dy = 0; dy < screen_h; dy++) {
            int src_y = y_map[dy];
            const uint16_t *src_row = &work_buf[src_y * width];
            uint16_t *dst_row = &scaled[dy * screen_w];
            for (int dx = 0; dx < screen_w; dx++) {
                int src_x = x_map[dx];
                dst_row[dx] = src_row[src_x];
            }
        }
    } else {
        int visible_src_w = (int)((int64_t)screen_w * height / screen_h);
        if (visible_src_w > width) visible_src_w = width;
        int src_x_offset = (width - visible_src_w) / 2;

        static int *y_map = nullptr;
        static int y_map_cap = 0;
        if (y_map_cap < screen_h) {
            if (y_map) free(y_map);
            y_map = (int *)malloc(screen_h * sizeof(int));
            y_map_cap = screen_h;
        }
        for (int dy = 0; dy < screen_h; dy++) {
            y_map[dy] = (int)((int64_t)dy * height / screen_h);
        }

        static int *x_map = nullptr;
        static int x_map_cap = 0;
        if (x_map_cap < screen_w) {
            if (x_map) free(x_map);
            x_map = (int *)malloc(screen_w * sizeof(int));
            x_map_cap = screen_w;
        }
        for (int dx = 0; dx < screen_w; dx++) {
            x_map[dx] = src_x_offset + (int)((int64_t)dx * visible_src_w / screen_w);
            // **水平镜像修改**
            x_map[dx] = width - 1 - x_map[dx];
        }

        for (int dy = 0; dy < screen_h; dy++) {
            int src_y = y_map[dy];
            const uint16_t *src_row = &work_buf[src_y * width];
            uint16_t *dst_row = &scaled[dy * screen_w];
            for (int dx = 0; dx < screen_w; dx++) {
                int src_x = x_map[dx];
                dst_row[dx] = src_row[src_x];
            }
        }
    }
```

* **TFT任务（tft_task）**

在一个循环中，不断获取摄像头帧缓冲区，并调用`tft_show_rgb565()`函数将图像显示到TFT屏幕，随后释放帧缓冲区。

```
 void tft_task(void *pvParameters) {
    camera_fb_t *fb = nullptr;

    while (true) {
        // 获取摄像头帧
        fb = esp_camera_fb_get();
        if (!fb) {
            Serial.println("Camera capture failed");
            vTaskDelay(100 / portTICK_PERIOD_MS);
            continue;
        }

        //显示画面
        tft_show_rgb565((const uint16_t *)fb->buf, fb->width, fb->height);

        // 释放摄像头帧
        esp_camera_fb_return(fb);

        vTaskDelay(33 / portTICK_PERIOD_MS);
    }
}
```



## 3.3 人脸识别

### 3.3.1 项目说明

本节旨在为用户介绍如何使用WonderLLM的人脸识别功能。

### 3.3.2 程序下载

1. 将Type-C数据线一端连接WonderLLM另一端连接电脑的USB接口。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image1.png" width="400px" />

2. 打开本文档同路径下的“**附录\03 WonderLLM程序\FaceDetection\FaceDetection.ino**”程序文件。

<img src="..\_static\media/chapter_3/section_3/media/image2.png" style="width:5.76458in;height:2.37431in" />

3. 接着选择“**ESP32S3 Dev Module**”开发板。

<img src="..\_static\media/chapter_3/section_3/media/image3.png" style="width:5.76458in;height:0.42292in" />

4. 点击菜单栏的“工具”，按照下图选择相应的ESP32S3的开发板配置。

<img src="..\_static\media/chapter_3/section_3/media/image4.png" style="width:3.99653in;height:3.25069in"  />

5. 最后点击<img src="..\_static\media/chapter_3/section_3/media/image5.png" style="width:0.375in;height:0.375in" />将代码下载至WonderLLM内，等待烧录完成即可。

<img src="..\_static\media/chapter_3/section_3/media/image3.png" style="width:5.76458in;height:0.42292in" />

<img src="..\_static\media/chapter_3/section_3/media/image6.png" style="width:5.76389in;height:0.52292in" />



### 3.3.3 功能演示

1. 确认Type-C数据线一端连接WonderLLM另一端连接电脑的USB接口中。

2. 打开“**附录\02 串口调试助手**”路径下的串口调试工具。

3. 选择端口，此处以COM11为例（**端口号不唯一，如果是COM1请不要选择，它是系统通信端口**），将波特率设置为“**115200**”。

   <img src="..\_static\media/chapter_3/section_3/media/image7.png" style="width:150px"  class="common_img" />

4. 点击页面左上方的<img src="..\_static\media/chapter_3/section_3/media/image8.png" style="width:0.77083in;height:0.30347in" />按钮打开串口通信，WonderLLM识别到人脸后，会在串口打印出人脸的坐标位置。

   例如：

   若接收到了**“center_x:103,center_y:114,width:185,length:247”**数据，则表明识别到了人脸，其中center_x、center_y为人脸方框的左上角坐标，width、length为人脸方框的宽和高，单位皆为1个像素格。

   <img src="..\_static\media/chapter_3\section_3/media/image9.png" style="width:5.76389in;height:5.00347in" alt="IMG_256" />



## 3.4 颜色识别

### 3.4.1 项目说明

 本节旨在为用户介绍如何使用WonderLLM视觉模块的颜色识别功能，以及修改需要识别颜色。

<p id ="anther3.4.2"></p>

### 3.4.2 程序下载

1. 使用Type-C线连接WonderLLM上方的Type-C接口。

   <img class="common_img" src="..\_static\media/chapter_3/section_4/media/image1.png" width="400px" />

2. 打开程序**“附录\03 WonderLLM程序\ColorDetection\ColorDetection.ino”**。

   <img class="common_img" src="..\_static\media/chapter_3/section_4/media/image2.png" />

3. 选择**“ESP32S3 Dev Module”**开发板。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image3.png" />

4. 点击菜单栏的**“工具”**，按照下图选择相应的ESP32S3的开发板配置。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image4.png" />

5. 最后点击<img src="..\_static\media/chapter_3/section_4/media/image5.png" style="width:40px"/>将代码下载至WonderLLM内，等待烧录完成即可。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image3.png" />

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image6.png" />

### 3.4.3 功能演示

1. 确认Type-C数据线一端连接WonderLLM另一端连接电脑的USB接口中。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image1.png" width="400px" />

2. 打开“**附录\02 串口调试助手**”路径下的串口调试工具。

3. 选择端口，此处以COM9为例（**端口号不唯一，如果是COM1请不要选择，它是系统通信端口**），将波特率设置为“**115200**”。

<img src="..\_static\media\chapter_3\section_4\media\image7.png" style="width:150px"  class="common_img" />

4. 点击页面左上方的<img src="..\_static\media\chapter_3\section_4\media\image8.png" style="width:70px" />按钮打开串口通信，WonderLLM模块识别到预设的颜色后，会在串口打印出当前识别到的HSV颜色索引。

<img src="..\_static\media\chapter_3\section_4\media\image9.png" style="width:600px"  class="common_img" />

例如：

接收到**“color\[0\]”**，则表示识别到了红色的HSV颜色值。


```c
vector<color_info_t> std_color_info = {
    {{151, 15, 70, 255, 90, 255}, 64, "red"},
    {{23, 34, 70, 255, 90, 255}, 64, "yellow"},
    {{44,69,67,199,109,226}, 64, "green"}, 
    {{97, 117, 70, 255, 90, 255}, 64, "blue"}, 
    {{130, 155, 70, 255, 90, 255}, 64, "purple"}
};
```



### 3.4.4 功能延伸

这里以修改WonderLLM识别到的颜色来进行说明。具体修改内容可参考下面步骤：

1. 打开本文档同路径下的“**附录\08 颜色阈值调整工具\HSV\HSV.dist\HSV.exe**”文件.

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image11.png" />

2. 点击选择图像，选择需要导入的图像文件。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image12.png" />

3. 拉动滑动条，对图像进行HSV阈值分割，调整到合适的HSV阈值范围，可参考下面的颜色范围表格进行调整。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image13.png" />

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image14.png" />

4. 然后将HSV阈值保存，打开本文档同路径下的“**附录\03 WonderLLM程序\ColorDetection\color_detection.cpp**”文件(第67行)，对颜色数据进行修改，更改为保存的HSV数组,最后参考“[3.4.2 程序下载](#anther3.4.2)”将修改好后的程序烧录进WonderLLM内。

```c
vector<color_info_t> std_color_info = {
    {{151, 15, 70, 255, 90, 255}, 64, "red"},
    {{23, 34, 70, 255, 90, 255}, 64, "yellow"},
    {{44,69,67,199,109,226}, 64, "green"}, 
    {{97, 117, 70, 255, 90, 255}, 64, "blue"}, 
    {{130, 155, 70, 255, 90, 255}, 64, "purple"}
};
```

> [!NOTE]
>
> **需要注意上述数组的元素格式与逗号分隔。**

5. 烧录完成后WonderLLM摄像头就能实现识别出其他颜色的物体。



### 3.4.5 常见问题解答

问1：摄像头识别到的颜色不准确或误识别。

答：请尽量减少背景杂色，可以使用单色背景或背景较为简单的环境。



## 3.5 巡线识别

### 3.5.1 项目说明

 本节旨在为用户介绍如何使用WonderLLM视觉模块的巡线识别功能，以及修改需要循迹的线段颜色。

### 3.5.2 程序下载

1. 使用Type-C线连接WonderLLM上方的Type-C接口。

   <img class="common_img" src="..\_static\media/chapter_3/section_5/media/image1.png" width="400px" />

2. 打开程序**“附录\03 WonderLLM程序\LineTracking\LineTracking.ino”**。

   <img class="common_img" src="..\_static\media/chapter_3/section_5/media/image2.png" />

3. 选择**“ESP32S3 Dev Module”**开发板。

<img class="common_img" src="..\_static\media/chapter_3/section_5/media/image3.png" />

4. 点击菜单栏的**“工具”**，按照下图选择相应的ESP32S3的开发板配置。

<img class="common_img" src="..\_static\media/chapter_3/section_5/media/image4.png" />

5. 最后点击<img src="..\_static\media/chapter_3/section_4/media/image5.png" style="width:40px"/>将代码下载至WonderLLM内，等待烧录完成即可。

<img class="common_img" src="..\_static\media/chapter_3/section_5/media/image3.png" />

<img class="common_img" src="..\_static\media/chapter_3/section_5/media/image6.png" />



### 3.5.3 功能演示

1. 确认Type-C数据线一端连接WonderLLM另一端连接电脑的USB接口中。

<img class="common_img" src="..\_static\media/chapter_3/section_5/media/image1.png" width="400px" />

2. 打开“**附录\02 串口调试助手**”路径下的串口调试工具。

3. 选择端口，此处以COM9为例（**端口号不唯一，如果是COM1请不要选择，它是系统通信端口**），将波特率设置为“**115200**”。

<img src="..\_static\media\chapter_3\section_5\media\image7.png" style="width:150px"  class="common_img" />

4. 点击页面左上方的<img src="..\_static\media\chapter_3\section_4\media\image8.png" style="width:70px" />按钮打开串口通信，当WonderLLM模块识别到预设的若干种颜色的线段后，会在串口打印出当前识别到的上下2个识别框参数。

>[!note]
>
>* **“==========”为每一次图像识别结果的分隔符。**
>* **预设的几种颜色中，只有被模块识别到的线段颜色数据才会打印出来，避免过多无效数据。**
>* **segment1为模块捕获图像上半部分的识别结果，segment2为模块捕获图像中半部分的识别结果。(下半部分默认不识别）**

<img src="..\_static\media\chapter_3\section_5\media\image9.png" style="width:600px"  class="common_img" />

例如：

接收到**“color_id:1”**，则表示识别到了绿色的HSV颜色值。

```c
vector<color_info_t> std_color_info = {
    { {0, 4, 165, 255, 102, 255}, 64, "red"},
    {{62, 73, 47, 255, 134, 255}, 64, "green"},
    {{91, 104, 45, 255, 167, 255}, 64, "blue"},
    {{125, 155, 70, 255, 90, 255}, 64, "purple"}
};
```



### 3.5.4 工作原理

<img src="..\_static\media\chapter_3\section_5\media\image16.png" style="width:600px"  class="common_img" />

1. 如上图，是一个对视觉巡线工作区域的简单介绍，当进入该模式工作时，模块会将采集到的图像，从上到下，分成3个区域进行处理。

2. 其中，最下面的区域3不进行任何处理、识别。

3. 检测区域1与检测区域2的工作机制相同，我们以检测区域1作为代表讲解，一个区域内，模块会同时按下述逻辑进行工作：

(1) 在一个检测区域中，模块会默认识别红、绿、蓝、紫几种颜色，识别到之后，会将色块在图像中用相同颜色的方框进行框定。

(2) 一个检测区域中，同一种颜色只会有1个识别框，如果同时出现多个相同色系的色块，模块会默认识别、框定在图像中显示面积最大的那一个。
>[!note]
>
>* **每种颜色相关的视觉巡线寄存器内记录了识别区域1或2中，在图像中对应颜色色块识别方框中心点坐标值和宽度、高度数据(单位：像素)，您可基于这些参数，结合模块安装情况（如模块安装高度、摄像头直射角度），设计规划图像坐标与实际空间坐标的映射关系函数，进一步真正实现视觉循线功能。**
>* **模块会同时在一个区域内，会同时识别预设的4种颜色，用户根据巡线需求(如专门循红线移动)，专门读取处理对应颜色的视觉巡线功能寄存器即可，模块对各颜色的识别并不会互相干扰。**



### 3.5.5 功能延伸

这里以修改WonderLLM识别到的颜色来进行说明。具体修改内容可参考下面步骤：

1. 打开本文档同路径下的“**附录\08 颜色阈值调整工具\HSV\HSV.dist\HSV.exe**”文件.

<img class="common_img" src="..\_static\media/chapter_3/section_5/media/image11.png" />

2. 点击选择图像，选择需要导入的图像文件。

<img class="common_img" src="..\_static\media/chapter_3/section_5/media/image12.png" />

3. 拉动滑动条，对图像进行HSV阈值分割，调整到合适的HSV阈值范围，可参考下面的颜色范围表格进行调整。

<img class="common_img" src="..\_static\media/chapter_3/section_5/media/image13.png" />

<img class="common_img" src="..\_static\media/chapter_3/section_5/media/image14.png" />

4. 然后将HSV阈值保存，打开本文档同路径下的“**附录\03 WonderLLM程序\ColorDetection\color_detection.cpp**”文件(第33行)，对颜色数据进行修改，更改为保存的HSV数组,最后参考“[3.4.2 程序下载](#anther3.4.2)”将修改好后的程序烧录进WonderLLM内。

```c
vector<color_info_t> std_color_info = {
    { {0, 4, 165, 255, 102, 255}, 64, "red"},
    {{62, 73, 47, 255, 134, 255}, 64, "green"},
    {{91, 104, 45, 255, 167, 255}, 64, "blue"},
    {{125, 155, 70, 255, 90, 255}, 64, "purple"}
};
```

> [!NOTE]
>
> **需要注意上述数组的元素格式与逗号分隔。**

5. 烧录完成后WonderLLM摄像头就能实现识别出其他颜色的物体。



## 3.6 设备主从通讯原理

### **3.6.1 **引言

1. 本节旨在为用户介绍关于WonderLLM模块在与不同设备（如Arduino、ESP32等主控）通信时的主从关系的详细信息，理解WonderLLM是如何作为从机与其他设备进行通信的，以及其他设备如何作为主机访问WonderLLM数据和控制的。

2. 本章中WonderLLM都是作为从机设备，通过IIC协议与其他设备进行信息传输。

   

### **3.6.2** 主从关系

在主从机控制系统中，WonderLLM作为从机设备，其他单片机等设备作为主机。

* **WonderLLM作为从机**

1. 接收解析主机发送的信号：

   等待IIC信号中断，若IIC有数据接收到，则根据IIC接收到的寄存器地址信息，调用对应的函数功能。

2. 数据处理与反馈：

   当WonderLLM接收到读取寄存器命令时，则需要调用对应的发送函数，将识别到的数据发送给主机设备。
   
   

* **其他设备作为主机**

1. 指令发送：

   主机需要将读取数据发送给WonderLLM。

2. 控制协调：

   主机设备需管理好整个系统的协同工作，确保主机与WonderLLM和主机连接的其他设备之间的通信和操作无冲突，保持良好的工作状态。

3. 数据接收：

   主机读取数据时，在发送读取指令后，需要接收WonderLLM发送的状态信息数据，并解析数据包，提取其中的有用信息。
   
   

### **3.6.3 **设备地址及寄存器
1. 当WonderLLM为**人脸识别**功能时：

<table border="1" style="border-collapse: collapse; width: 100%;">
  <colgroup>
    <col style="width: 49%" />
    <col style="width: 50%" />
  </colgroup>
  <tr>
    <th style="padding: 8px; background-color: #f2f2f2;">地址</th>
    <th style="padding: 8px; background-color: #f2f2f2;">作用</th>
  </tr>
  <tr>
    <td style="padding: 8px;">0x52（设备地址）</td>
    <td style="padding: 8px;">WonderLLM的通讯地址</td>
  </tr>
  <tr>
    <td style="padding: 8px;">0x01（寄存器地址）</td>
    <td style="padding: 8px;">读取人脸数据【uint8_t x,y,w,h】（无人脸时，数据全为0）</td>
  </tr>
</table>     

 >[!note]
 >
 >* **表中的x,y,w,h人脸数据，分别为模块在原始图像中标注的人脸识别框：①中心点x轴坐标  ②中心点y轴坐标  ③识别框宽度  ④识别框高度**
 >
 >* **以上参数单位为像素，该模式像素坐标系的涉及详见“4.模块坐标系说明”。**


2. 当WonderLLM为**颜色识别**功能时：

<table border="1">
<colgroup>
<col style="width: 49%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr>
<td style="text-align: center;">地址</td>
<td style="text-align: center;">作用</td>
</tr>
<tr>
<td style="text-align: center;">0x52（设备地址）</td>
<td style="text-align: center;">WonderLLM的通讯地址</td>
</tr>
<tr>
<td style="text-align: center;">0x00（寄存器地址）</td>
<td style="text-align: center;"><p>读取颜色0(默认红色)数据，读取到的数据格式为</p>
<p>【uint8_t x,y,w,h】（无识别到时，数据全为0）</p></td>
</tr>
<tr>
<td style="text-align: center;">0x01（寄存器地址）</td>
<td style="text-align: center;"><p>读取颜色1(默认黄色)数据，读取到的数据格式为</p>
<p>【uint8_t x,y,w,h】（无识别到时，数据全为0）</p></td>
</tr>
<tr>
<td style="text-align: center;">0x02（寄存器地址）</td>
<td style="text-align: center;"><p>读取颜色2(默认绿色)数据，读取到的数据格式为</p>
<p>【uint8_t x,y,w,h】（无识别到时，数据全为0）</p></td>
</tr>
<tr>
<td style="text-align: center;">0x03（寄存器地址）</td>
<td style="text-align: center;"><p>读取颜色3(默认蓝色)数据，读取到的数据格式为</p>
<p>【uint8_t x,y,w,h】（无识别到时，数据全为0）</p></td>
</tr>
<tr>
<td style="text-align: center;">0x04（寄存器地址）</td>
<td style="text-align: center;"><p>读取颜色4(默认紫色)数据，读取到的数据格式为</p>
<p>【uint8_t x,y,w,h】（无识别到时，数据全为0）</p></td>
</tr>
</tbody>
</table>

>[!note]
>
>* **表中的x,y,w,h颜色数据，分别为模块在原始图像中标注的色块识别框：①中心点x轴坐标 ②中心点y轴坐标 ③识别框宽度 ④识别框高度**
>
>* **以上参数单位为像素，该模式像素坐标系的涉及详见“4.模块坐标系说明”。**
>* **若镜头中出现多个能够被预设颜色阈值识别的色块，模块会按在画面中的体积大小，选取最大的两个，将他们的识别框数据依次存入0x00、0x01寄存器空间。**

3. 当WonderLLM为**巡线识别**功能时：

<table border="1">
<colgroup>
<col style="width: 49%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr>
<td style="text-align: center;">地址</td>
<td style="text-align: center;">作用</td>
</tr>
<tr>
<td style="text-align: center;">0x52（设备地址）</td>
<td style="text-align: center;">WonderLLM的通讯地址</td>
</tr>
<tr>
<td style="text-align: center;">0xA0（寄存器地址）</td>
<td style="text-align: center;"><p>读取图像上半部分颜色0(默认红色)识别数据，读取到的数据格式为</p>
<p>【uint8_t x,y,w,h】（无识别到时，数据全为0）</p></td>
</tr>
<tr>
<td style="text-align: center;">0xA1（寄存器地址）</td>
<td style="text-align: center;"><p>读取图像中半部分颜色0(默认红色)识别结果，读取到的数据格式为</p>
<p>【uint8_t x,y,w,h】（无识别到时，数据全为0）</p></td>
</tr>
<tr>
<td style="text-align: center;">0xA2（寄存器地址）</td>
<td style="text-align: center;"><p>读取图像上半部分颜色1(默认绿色)识别结果，读取到的数据格式为</p>
<p>【uint8_t x,y,w,h】（无识别到时，数据全为0）</p></td>
</tr>
<tr>
<td style="text-align: center;">0xA3（寄存器地址）</td>
<td style="text-align: center;"><p>读取图像中半部分颜色1(默认绿色)识别结果，读取到的数据格式为</p>
<p>【uint8_t x,y,w,h】（无识别到时，数据全为0）</p></td>
</tr>
<tr>
<td style="text-align: center;">0xA4（寄存器地址）</td>
<td style="text-align: center;"><p>读取图像上半部分颜色2(默认蓝色)识别结果，读取到的数据格式为</p>
<p>【uint8_t x,y,w,h】（无识别到时，数据全为0）</p></td>
</tr>
<tr>
<td style="text-align: center;">0xA5（寄存器地址）</td>
<td style="text-align: center;"><p>读取图像中半部分颜色2(默认蓝色)识别结果，读取到的数据格式为</p>
<p>【uint8_t x,y,w,h】（无识别到时，数据全为0）</p></td>
</tr>
<tr>
<td style="text-align: center;">0xA6（寄存器地址）</td>
<td style="text-align: center;"><p>读取图像上半部分颜色3(默认紫色)识别结果，读取到的数据格式为</p>
<p>【uint8_t x,y,w,h】（无识别到时，数据全为0）</p></td>
</tr>
<tr>
<td style="text-align: center;">0xA7（寄存器地址）</td>
<td style="text-align: center;"><p>读取图像中半部分颜色3(默认紫色)识别结果，读取到的数据格式为</p>
<p>【uint8_t x,y,w,h】（无识别到时，数据全为0）</p></td>
</tr>
</tbody>
</table>

>[!note]
>* **表中的x,y,w,h颜色数据，分别为模块在原始图像中标注的色块识别框：①中心点x轴坐标 ②中心点y轴坐标 ③识别框宽度 ④识别框高度**
>* **以上参数单位为像素，该模式像素坐标系的涉及详见“4.模块坐标系说明”。**
>* **若镜头同一部分区域中出现多个能够被预设颜色阈值识别的色块，模块会按在画面中的体积大小，选取最大的两个，将他们的识别框数据依次存入0x00、0x01寄存器空间。**



### 3.6.4 模块坐标系说明

1. 本节简要的介绍模块工作在各功能时，摄像头屏幕采集到的图像坐标系的设计，读者在学习例程前需对此有所认知。

2. 在客户移植例程进行二次开发时，也需要参照此文档，自行建立模块图像坐标系与现实空间坐标系的映射关系。

3. 我们将模块图像坐标系值得注意的特殊之处在此简要介绍，请读者注意：**①原点并不在屏幕的正中央，而在屏幕的左上角**  **②Y轴的方向与常见的平面直角坐标系Y轴方向相反。**



* **图像回传模式**

<img src="..\_static\media/chapter_3/section_6/media/image2.png"  style="width:600px"  class="common_img"  />
>[!note]
>**图像回传模式采取该分辨率（320\*240），是出于适配我司手机APP端获取图像数据接口的需要**



* **人脸识别模式**

<img src="..\_static\media/chapter_3/section_6/media/image2.png"  style="width:600px"  class="common_img"  />
>[!note]
>**为了确保图像的流畅性，人脸识别模式采取的该分辨率（240\*240）为我司的测试后的取值。**



* **颜色识别模式**

<img src="..\_static\media/chapter_3/section_6/media/image3.png" style="width:600px"  class="common_img" />
>[!note]
>**为了确保图像的流畅性，颜色识别模式采取的该分辨率（160\*120）为我司的测试后取值。**



* **巡线识别模式**

<img src="..\_static\media/chapter_3/section_6/media/image4.png" style="width:600px"  class="common_img" />

>[!note]
>**为了确保图像的流畅性，颜色识别模式采取的该分辨率（160\*120）为我司的测试后取值。**



### 3.6.5 注意事项

主机设备与WonderLLM的供电电源可以不同，但在连接时必须要共地，才可以提供稳定的通讯电平。



## 3.7 与Arduino主机通讯

### **3.7.1 人脸识别例程**

本节通过WonderLLM模块识别人脸，再通过IIC协议将数据发送给Arduino主控板。

* #### **实现流程图**

<img src="../_static/media/chapter_3/section_7/media/image2.png" style="width:600px"  class="common_img" />



* #### **传感器接线**

  (1) 接线时，WonderLLM的5V、GND、SCL和SDA引脚需与Arduino UNO开发板进行连接，接线方式如下图所示：

  <img src="../_static/media/chapter_3/section_7/media/image3.png" style="width:600px"  class="common_img" />

  (2) Arduino UNO开发板可与我司任意一款Arduino扩展板搭配使用，与WonderLLM的接线方式如下图（以A板为例）：

  <img src="../_static/media/chapter_3/section_7/media/image3_1.png" style="width:600px"  class="common_img" />

>[!note]
>**注意：通电前确保不要有金属物体接触到主板，否则可能会因主板底部的引脚导致电路短路从而烧毁主板。**

  

1. **Arduino UNO程序下载**

(1) 找到并打开**“附录\04 Arduino程序文件\01 Arduino主板人脸识别例程\Arduino_esp32cam_face\Arduino_esp32cam_face.ino”**目录下的程序文件。

<img src="../_static/media/chapter_3/section_7/media/image5_1.png" style="width:600px"  class="common_img" />

(2) 将Arduino通过UNO数据线（Type-B）连接至电脑。

<img src="../_static/media/chapter_3/section_7/media/image6.png" style="width:600px"  class="common_img" />

(3) 点击**“选择开发板”**选项，软件会自动检测当前Arduino串口，点击进行连接。

<img src="../_static/media/chapter_3/section_7/media/image7.png" style="width:600px"  class="common_img" />

(4) 点击<img src="../_static/media/chapter_3/section_7/media/image8.png" style="width:40px"   />，将程序下载至Arduino中，等待下载完成即可。

<img src="../_static/media/chapter_3/section_7/media/image9.png" style="width:600px"  class="common_img" />

<img src="../_static/media/chapter_3/section_7/media/image10.png" style="width:600px"  class="common_img" />



2. **WonderLLM人脸识别程序下载**

(1) 将Type-C数据线一端连接WonderLLM另一端连接电脑的USB接口。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image1.png" width="400px" />

(2) 打开本文档同路径下的“**附录\03 WonderLLM程序\FaceDetection\FaceDetection.ino**”程序文件。

<img src="..\_static\media/chapter_3/section_3/media/image2.png" style="width:5.76458in;height:2.37431in" />

(3) 接着选择“**ESP32S3 Dev Module**”开发板。

<img src="..\_static\media/chapter_3/section_3/media/image3.png" style="width:5.76458in;height:0.42292in" />

(4) 点击菜单栏的**“工具”**，按照下图选择相应的ESP32S3的开发板配置。

<img src="..\_static\media/chapter_3/section_3/media/image4.png" style="width:3.99653in;height:3.25069in"  />

(5) 最后点击<img src="..\_static\media/chapter_3/section_3/media/image5.png"  style="width:40px" />将代码下载至WonderLLM内，等待烧录完成即可。

<img src="..\_static\media/chapter_3/section_3/media/image3.png" style="width:5.76458in;height:0.42292in" />

<img src="..\_static\media/chapter_3/section_3/media/image6.png" style="width:5.76389in;height:0.52292in" />

* #### 实现效果

1. 打开Arduino IDE右上角的串口工具<img src="../_static/media/chapter_3/section_7/media/image15.png"  style="width:50px" />，波特率设置为115200：

2. 当WonderLLM未识别到人脸时，Arduino会在串口打印出**“face 0”**。

   <img src="../_static/media/chapter_3/section_7/media/image15_1.png" style="width:800px"  class="common_img" />

3. 识别到人脸后，将会在串口打印出**“find face”**和**“face 1”**。

   <img src="../_static/media/chapter_3/section_7/media/image16_1.png" style="width:800px"  class="common_img" />

   

* #### 程序简要分析

1. **程序初始化**

(1) 首先导入例程所需的WonderLLM离线视觉功能的通讯库。

```c
#include "hw_esp32cam_ctl.h" //导入ESP32Cam通讯库
```

(2) 创建一个WonderLLM通讯对象hw_cam用于Arduino UNO与WonderLLM的通讯。

```c
//ESP32Cam通讯对象
HW_ESP32Cam hw_cam;
```

(3) 在`setup()`函数中，主要是对相关的硬件设备进行初始化。首先是串口，将其通信的波特率设置为115200以及读取数据超时时间为600ms，接着是WonderLLM的通讯初始化。

```c
void setup() {
  Serial.begin(115200);
  // 设置串行端口读取数据的超时时间
  Serial.setTimeout(600);
  
  hw_cam.begin(); //初始化与ESP32Cam通讯接口

  delay(600);
  Serial.println("start");
}
```



2. **循环调用子函数**

初始化完成后，进入`loop`主函数，依次循环调用“**espcam_task**”函数，检测人脸识别，执行串口打印任务。

```c
void loop() {
  // esp32cam通讯任务
  espcam_task();
}
```



3. **WonderLLM通讯任务**

(1) 定义“**espcam_task**”函数，检测人脸识别，执行串口打印任务。

(2) 首先定义了`last_tick`变量，用于记录上一次任务执行的时间点；res变量用于储存是否识别到人脸数据（1为是，0为否）。

```c
static uint32_t last_tick = 0;
int res = 0;
```

(3) `last_tick`变量结合`millis()`作**延时操作**，具体的通过`millis()`函数获取到当前程序运行的时间，与`last_tick`变量作差，如果差值小于100，则跳出该函数；如果大于或等于100，则意味着已经延时了100ms，接着再将当前的时间赋值给`last_tick`变量，用作下一次的延时操作。

```c
  if (millis() - last_tick < 100) {
    return;
  }
  last_tick = millis();
```

(4) 调用`hw_cam`对象的`faceDetect`函数，通过IIC向WonderLLM模块读取检测到的人脸数据。

```c
  res = hw_cam.faceDetect();
```

(5) 最后判断当前是否检测到人脸数据，若检测到则通过串口打印**“find face”**。

```c
  if(res != 0)
  {
    Serial.println("find face");
  }
```



### 3.7.2 颜色识别例程

本节通过WonderLLM识别对应的颜色，通过IIC协议将数据发送给Arduino主控板。

* #### 实现流程图

<img src="../_static/media/chapter_3/section_7/media/image2.png" style="width:5.76181in;height:1.10139in"  />



* #### 传感器接线

(1) 接线时，WonderLLM的5V、GND、SCL和SDA引脚需与Arduino UNO开发板进行连接，接线方式如下图所示：

<img src="../_static/media/chapter_3/section_7/media/image3.png" style="width:600px"  class="common_img" />

(2) Arduino UNO开发板可与我司任意一款Arduino扩展板搭配使用，与WonderLLM的接线方式如下图（以A板为例）：

<img src="../_static/media/chapter_3/section_7/media/image3_1.png" style="width:600px"  class="common_img" />

>[!note]
>
>**注意：通电前确保不要有金属物体接触到主板，否则可能会因主板底部的引脚导致电路短路从而烧毁主板。**



* #### 程序下载

1. **Arduino UNO程序下载**

(1) 找到并打开本节同目录下的**“附录\04 Arduino程序文件\02 Arduino主板颜色识别例程\Arduino_esp32cam_color\Arduino_esp32cam_color.ino”**程序文件。

<img src="../_static/media/chapter_3/section_7/media/image5.png" style="width:600px"  class="common_img" />

(2) 将Arduino通过UNO数据线（Type-B）连接至电脑。

<img src="../_static/media/chapter_3/section_7/media/image6.png" style="width:600px"  class="common_img" />

(3) 点击**“选择开发板”**选项，软件会自动检测当前Arduino串口，点击进行连接。

<img src="../_static/media/chapter_3/section_7/media/image7.png" style="width:600px"  class="common_img" />

(4) 点击<img src="../_static/media/chapter_3/section_7/media/image8.png"  style="width:40px" />，将程序下载至Arduino中，等待下载完成即可。

<img src="../_static/media/chapter_3/section_7/media/image9.png" style="width:600px"  class="common_img" />

<img src="../_static/media/chapter_3/section_7/media/image10.png" style="width:600px"  class="common_img" />



2. **WonderLLM颜色识别程序下载**

(1) 使用Type-C线连接WonderLLM上方的Type-C接口。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image1.png" width="400px" />

(2) 打开程序**“附录\03 WonderLLM程序\ColorDetection\ColorDetection.ino”**。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image2.png" />

(3) 选择**“ESP32S3 Dev Module”**开发板。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image3.png" />

(4) 点击菜单栏的**“工具”**，按照下图选择相应的ESP32S3的开发板配置。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image4.png" />

(5) 最后点击<img src="..\_static\media/chapter_3/section_4/media/image5.png" style="width:40px"/>将代码下载至WonderLLM内，等待烧录完成即可。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image3.png" />

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image6.png" />



* **实现效果**

1. 打开Arduino IDE右上角的串口工具<img src="../_static/media/chapter_3/section_7/media/image15.png"  style="width:50px" />，波特率设置为115200：

2. 当WonderLLM 识别到红色，会在串口打印出**“COLOR_1”**；

<img src="../_static/media/chapter_3/section_7/media/image16.png" style="width:5.76597in;height:2.9875in" />

3. 当WonderLLM 识别到绿色，会在串口打印出**“COLOR_2”**。

<img src="../_static/media/chapter_3/section_7/media/image17.png" style="width:5.7625in;height:2.93889in" />



* **程序简要分析**

1. **程序初始化**

(1) 首先导入例程所需的WonderLLM离线视觉功能的通讯库。

```c
#include "hw_esp32cam_ctl.h" //导入ESP32Cam通讯库
```

(2) 接着创建一个WonderLLM通讯对象用于Arduino UNO与WonderLLM的通讯，定义WonderLLM模块颜色识别功能中红色、绿色对应ID。

```c
#define COLOR_red   0
#define COLOR_green   2

//ESP32Cam通讯对象
HW_ESP32Cam hw_cam;
```

(3) 在`setup()`函数中，主要是对相关的硬件设备进行初始化。首先是串口，将其通信的波特率设置为115200以及读取数据超时时间为600ms，接着是WonderLLM的通讯初始化。

```c
void setup() {
  Serial.begin(115200);
  // 设置串行端口读取数据的超时时间
  Serial.setTimeout(600);
  
  hw_cam.begin(); //初始化与ESP32Cam通讯接口

  delay(600);
  Serial.println("start");
}
```

2. **循环调用子函数**

初始化完成后，进入`loop`主函数，依次循环调用“**espcam_task**”函数，检测颜色识别，执行串口打印任务。

```c
void loop() {
  // esp32cam通讯任务
  espcam_task();
}
```

3. **WonderLLM通讯任务**

(1) 定义“**espcam_task**”函数，检测人脸识别，执行串口打印任务。

(2) 首先定义了`last_tick`变量，用于记录上一次任务执行的时间点；`color_results`数组用于储存模块所有预设颜色的实时识别结果。

```c
  static uint32_t last_tick = 0;
  uint8_t color_result[Color_num] = {0x00};
```

(3) `last_tick`变量结合`millis()`作**延时操作**，具体的通过`millis()`函数获取到当前程序运行的时间，与`last_tick`变量作差，如果差值小于100，则跳出该函数；如果大于或等于100，则意味着已经延时了100ms，接着再将当前的时间赋值给`last_tick`变量，用作下一次的延时操作。

```c
  if (millis() - last_tick < 100) {
    return;
  }
  last_tick = millis();
```

(4) 调用hw_cam对象的colorDetect函数，通过IIC向WonderLLM模块读取检测到的颜色数据。

```c
if(hw_cam.colorDetect(color_result)){ //获取颜色识别结果，并根据返回值判断是否获取成功
```

(5) 该函数通过IIC读取WonderLLM的所有预设颜色寄存器数据，并分别解析数据，当任意一种颜色识别框宽度为0时，即判定为没有识别到该颜色，识别结果数组对应元素写入0；反之写入该颜色ID。

```c
/**
* @brief 获取对模块预设所有颜色的识别结果。
*
* @param color_result_info 存放模块对各颜色的识别结果数组指针。 
* @return 读取结果(true-读取成功 false-读取失败)。
*
* @note 1.color_result_info参数需传入 Color_num 字节uint8_t类型数组的指针
*       2.数组每一个元素存放一种颜色的识别结果，存放顺序为ID从低至高对应的颜色
*       3.若某一种颜色未被识别到，对应元素值为0，反之取值为对应ID
*/
bool colorDetect(uint8_t * color_result_info)
{
  uint8_t color_info[4];
  int num = 0;
  memset(color_result_info, -1, (Color_num * sizeof(uint8_t)));
  
  for(int i = 0; i < Color_num; i ++){

    num = WireReadDataArray(Color0_Detect_Reg + i,color_info,4);
    if(num != 4) //没有完整接收识别到的颜色的x,y,w,h值
    {
      return false;
    }

    if(color_info[2] > 0){ //识别框宽度=0--未识别到，反之为识别到
      color_result_info[i] = i;
    }

  }

  return true;
}
```

(6) 最后判断检测结果中当前是否识别到红色/绿色，识别到则串口打印对应的颜色标签（红色打印**“COLOR 1”**；绿色打印**“COLOR 2”**）。

```c
if(hw_cam.colorDetect(color_result)){ //获取颜色识别结果，并根据返回值判断是否获取成功
	if(color_result[COLOR_red] == COLOR_red)
	{
		Serial.println("COLOR 1");

	}
    if(color_result[COLOR_green] == COLOR_green)
	{
		Serial.println("COLOR 2");
	}

	}else{
		Serial.println("read failed");
	} 
```



### 3.7.3 巡线识别例程

本节通过WonderLLM识别指定颜色的线段，通过IIC协议将数据发送给Arduino主控板。

* #### 实现流程图

<img src="../_static/media/chapter_3/section_7/media/image2_2.png" style="width:5.76181in;height:1.10139in"  />



* #### 传感器接线

(1) 接线时，WonderLLM的5V、GND、SCL和SDA引脚需与Arduino UNO开发板进行连接，接线方式如下图所示：

<img src="../_static/media/chapter_3/section_7/media/image3.png" style="width:600px"  class="common_img" />

(2) Arduino UNO开发板可与我司任意一款Arduino扩展板搭配使用，与WonderLLM的接线方式如下图（以A板为例）：

<img src="../_static/media/chapter_3/section_7/media/image3_1.png" style="width:600px"  class="common_img" />

>[!note]
>**通电前确保不要有金属物体接触到主板，否则可能会因主板底部的引脚导致电路短路从而烧毁主板。**



* #### 程序下载

1. **Arduino UNO程序下载**

(1) 找到并打开本节同目录下的**“附录\04 Arduino程序文件\03 Arduino主板巡线识别例程\Arduino_esp32cam_linetrack\Arduino_esp32cam_linetrack.ino”**程序文件。

<img src="../_static/media/chapter_3/section_7/media/image5_2.png" style="width:700px"  class="common_img" />

(2) 将Arduino通过UNO数据线（Type-B）连接至电脑。

<img src="../_static/media/chapter_3/section_7/media/image6.png" style="width:600px"  class="common_img" />

(3) 点击**“选择开发板”**选项，软件会自动检测当前Arduino串口，点击进行连接。

<img src="../_static/media/chapter_3/section_7/media/image7.png" style="width:600px"  class="common_img" />

(4) 点击<img src="../_static/media/chapter_3/section_7/media/image8.png"  style="width:40px" />，将程序下载至Arduino中，等待下载完成即可。

<img src="../_static/media/chapter_3/section_7/media/image9.png" style="width:600px"  class="common_img" />

<img src="../_static/media/chapter_3/section_7/media/image10.png" style="width:600px"  class="common_img" />



2. **WonderLLM巡线识别程序下载**

(1) 使用Type-C线连接WonderLLM上方的Type-C接口。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image1.png" width="400px" />

(2) 打开程序**“附录\03 WonderLLM程序\LineTracking\LineTracking.ino”**。

<img class="common_img" src="..\_static\media/chapter_3/section_7/media/image11_2.png" />

(3) 选择**“ESP32S3 Dev Module”**开发板。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image3.png" />

(4) 点击菜单栏的**“工具”**，按照下图选择相应的ESP32S3的开发板配置。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image4.png" />

(5) 最后点击<img src="..\_static\media/chapter_3/section_4/media/image5.png" style="width:40px"/>将代码下载至WonderLLM内，等待烧录完成即可。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image3.png" />

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image6.png" />



* **实现效果**

1. 打开Arduino IDE右上角的串口工具<img src="../_static/media/chapter_3/section_7/media/image15.png"  style="width:50px" />，波特率设置为115200：

2. 当WonderLLM 识别到红色线段，会在串口打印出了上半部分、中半部分两个识别框的参数；(若未识别到，打印参数为全0)

<img src="../_static/media/chapter_3/section_7/media/image16_2.png" style="width:700px"  class="common_img" />



* **程序简要分析**

1. **程序初始化**

(1) 首先导入例程所需的WonderLLM离线视觉功能的通讯库。

```c
#include "hw_esp32cam_ctl.h" //导入ESP32Cam通讯库
```

(2) 接着创建一个WonderLLM通讯对象用于Arduino UNO与WonderLLM的通讯，定义红色在模块巡线识别功能中的预设ID。

```c
#define COLOR_red   0

//ESP32Cam通讯对象
HW_ESP32Cam hw_cam;
```

(3) 在`setup()`函数中，主要是对相关的硬件设备进行初始化。首先是串口，将其通信的波特率设置为115200以及读取数据超时时间为600ms，接着是WonderLLM的通讯初始化。

```c
void setup() {
  Serial.begin(115200);
  // 设置串行端口读取数据的超时时间
  Serial.setTimeout(600);
  
  hw_cam.begin(); //初始化与ESP32Cam通讯接口

  delay(600);
  Serial.println("start");
}
```



2. **循环调用子函数**

(1) 初始化完成后，进入`loop`主函数，依次循环调用“**espcam_task**”函数，检测人脸识别，执行串口打印任务。

```c
void loop() {
  // esp32cam通讯任务
  espcam_task();
}
```



3. **WonderLLM通讯任务**

(1) 定义“**espcam_task**”函数，检测巡线识别，执行串口打印任务。

(2) 首先定义了`last_tick`变量，用于记录上一次任务执行的时间点；`line_info`数组用于储存同一种颜色两个识别框的参数。

```c
  static uint32_t last_tick = 0;
  uint8_t line_info[8];
```

(3) `last_tick`变量结合`millis()`作**延时操作**，具体的通过`millis()`函数获取到当前程序运行的时间，与`last_tick`变量作差，如果差值小于100，则跳出该函数；如果大于或等于100，则意味着已经延时了100ms，接着再将当前的时间赋值给`last_tick`变量，用作下一次的延时操作。

```c
  if (millis() - last_tick < 100) {
    return;
  }
  last_tick = millis();
```

(4) 调用`hw_cam`对象的`line_position`函数，通过IIC向WonderLLM模块读取检测到的红色线段识别框数据。

```c
  if(hw_cam.line_position(COLOR_red,line_info)){
```

(5) 该函数通过IIC读取WonderLLM的指定颜色的线段寄存器数据，全部8字节数据读取成功后则返回true，否则返回false。

```c
/**
* @brief 获取指定颜色线段的识别框(2个)参数。
*
* @param color_id   颜色ID。
* @param line_info 线段识别框参数数组指针。
* @return 读取结果(true-读取成功 false-读取失败)。
*
* @note 1.color_info参数需传入8字节uint8_t类型数组的指针
*       2.color_id =0(默认红色)，color_id =1(默认绿色)，color_id =2(默认蓝色)，color_id =3(默认紫色)
*/
bool HW_ESP32Cam::line_position(int color_id,uint8_t *line_info)
{
  //确认color_id参数有效性
  if((color_id >= 0) && (color_id <= Color_line_num)){

    int num = WireReadDataArray((Color0_segment1_Detect_Reg + (2*color_id)),line_info,4);
    //接收到完整4字节的上半部分图像线段颜色识别框的x,y,w,h值
    if(num != 4){
      
      return false;
    }

    num = WireReadDataArray((Color0_segment2_Detect_Reg + (2*color_id)),(line_info + 4),4);
    //接收到完整4字节的中半部分图像线段颜色识别框的x,y,w,h值
    if(num != 4){

      return false;
    }

  }

  return true;
}
```

(6) 最后将红色线段两个识别框的参数全部打印出来。(若为全0，说明该区域并未识别到红色线段)

```c
  if(hw_cam.line_position(COLOR_red,line_info)){
  
    Serial.print("segment1:");      //上半部分区域

    Serial.print("  center_x: ");
    Serial.print(line_info[0]);

    Serial.print("  center_y: ");
    Serial.print(line_info[1]);

    Serial.print("  width: ");
    Serial.print(line_info[2]);

    Serial.print("  height: ");
    Serial.println(line_info[3]);

    Serial.print("segment2:");      //中半部分区域

    Serial.print("  center_x: ");
    Serial.print(line_info[4]);

    Serial.print("  center_y: ");
    Serial.print(line_info[5]);

    Serial.print("  width: ");
    Serial.print(line_info[6]);

    Serial.print("  height: ");
    Serial.println(line_info[7]);

  }else{
    Serial.println("read failed");
  }

  Serial.println();
```



## 3.8 与ESP32主机通讯

### 3.8.1 人脸识别例程

本节通过WonderLLM识别人脸，再通过IIC协议将数据发送给ESP32主控板。

* #### 实现流程图

<img src="../_static/media/chapter_3/section_7/media/image2_1.png" style="width:5.76389in;height:1.10208in" alt="IMG_256" />



* #### **接线说明**

>[!note]
>
>**MicroPython代码可在任意支持MicroPython编程的主控上运行，为讲解方便，此处以我司ESP32核心板为例讲解说明。**

1)  接线时，WonderLLM的5V、GND、SCL和SDA引脚需与ESP32核心板进行连接，接线方式如下图所示：

<img src="../_static/media/chapter_2/section_2/media/image19.png" style="width:600px"  class="common_img" />


2)  ESP32核心板可与我司开源6路舵机控制器搭配使用，与WonderLLM的接线方式如下图：

<img src="../_static/media/chapter_2/section_2/media/image20.png" style="width:600px"  class="common_img" />


>[!note]
>
>**通电前确保不要有金属物体接触到主板，否则可能会因主板底部的引脚导致电路短路从而烧毁主板。**



* #### 程序下载

1. **ESP32程序下载**
>[!note]
>
>* **Micropython支持多种IDE下载，如Thoony、VScode（需安装相关插件），相关操作请用户自行检索，此处以我司“幻尔python编辑器”下载程序为例，可实现免安装使用，开箱即用。**
>* **如使用ESP32，在下载Micropython前，需确保ESP32中已烧录Micropython固件，相关固件下载请见Micropython官网。如使用我司ESP32核心板，也可直接烧录我司提供固件文件（路径：\附录\10  ESP32核心板固件及烧录软件\02 ESP32固件烧录工具，烧录方式见同路径文档。**

1. 打开“**幻尔Python编辑器**”软件<img src="../_static/media/chapter_2/section_2/media/image1.png"  style="width:50px" />（路径：**附录\09  幻尔python编辑器**）；

2. 将本文档路径下的“**附录\05 ESP32程序文件\01 ESP32主控人脸识别例程\main.py**”文件，拖到幻尔Python编辑器中（需要拖到红框内区域才有效）；

   <img src="../_static/media/chapter_2/section_2/media/image2.png" style="width:600px"  class="common_img" />

3. 点击菜单栏的连接按钮<img src="../_static/media/chapter_2/section_2/media/image3.png" style="width:50px  " />，连接成功后会变为绿色的图标<img src="../_static/media/chapter_2/section_2/media/image4.png" style="width:50px"  />；

4. 连接成功后点击菜单栏上的下载按钮<img src="../_static/media/chapter_2/section_2/media/image5.png"  style="width:50px" />，将程序下载至ESP32内，等待下方信息交互方框内提示下载完成。

   <img src="..\_static\media\chapter_2\section_2/media/image6.png" style="width:600px"  class="common_img" />

>[!note]
>**完成以上4步后，请再将WonderLLM离线视觉功能通信库(“附录\05 ESP32程序文件\01 ESP32主控人脸识别例程\hw_esp32cam_ctl.py”)拖入，按照上述步骤说明重复操作将该库文件导入ESP32，下载完成后点击界面的复位图标<img src="../_static/media/chapter_3/section_8/media/image6_2.png"  style="width:50px" />即可使ESP32复位工作，输出信息会同步显示在下方输出信息栏。**



2. **WonderLLM人脸识别程序下载**

(1) 将Type-C数据线一端连接WonderLLM另一端连接电脑的USB接口。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image1.png" width="400px" />

(2) 打开本文档同路径下的“**附录\03 WonderLLM程序\FaceDetection\FaceDetection.ino**”程序文件。

<img src="..\_static\media/chapter_3/section_3/media/image2.png" style="width:5.76458in;height:2.37431in" />

(3) 接着选择“**ESP32S3 Dev Module**”开发板。

<img src="..\_static\media/chapter_3/section_3/media/image3.png" style="width:5.76458in;height:0.42292in" />

(4) 点击菜单栏的**“工具”**，按照下图选择相应的ESP32S3的开发板配置。

<img src="..\_static\media/chapter_3/section_3/media/image4.png" style="width:3.99653in;height:3.25069in"  />

(5) 最后点击<img src="..\_static\media/chapter_3/section_3/media/image5.png"  style="width:40px" />将代码下载至WonderLLM内，等待烧录完成即可。

<img src="..\_static\media/chapter_3/section_3/media/image3.png" style="width:5.76458in;height:0.42292in" />

<img src="..\_static\media/chapter_3/section_3/media/image6.png" style="width:5.76389in;height:0.52292in" />



* #### **实现效果**

1. 当WonderLLM识别到人脸时，会在串口打印出**“find face”**。

   <img src="../_static/media/chapter_3/section_8/media/image13.png" style="width:5.76806in;height:3.13194in" />



* #### 程序简要分析

1. **导入库文件**

(1)导入IIC模块、WonderLLM离线视觉功能模块hw_esp32cam_ctl。

```python
from time import sleep_ms
from machine import Pin , I2C
from hw_esp32cam_ctl import HW_ESP32Cam 
```

(2) 定义人脸识别结果变量`face_detect_result`，初始化默认为false(未识别到)。

```python
face_detect_result = False
```



2. **初始化IIC**

初始化IIC总线，并将IIC总线句柄传入，将HW_ESP32Cam类实例化为对象cam。

```python
if __name__ == "__main__":
  iic = I2C(0, scl=Pin(23), sda=Pin(22), freq=100000)
  cam = HW_ESP32Cam(iic)
  sleep_ms(1000)
```

3. **循环调用子函数**

(1) 调用`faceDetect()`函数读取模块人脸识别结果，若识别到人脸，则打印**“find face”**。

```python
  while True:

    face_detect_result = cam.faceDetect()
    
    if (face_detect_result == True):
        print("find face")

    sleep_ms(600)
```



### 3.8.2 颜色识别例程

本节通过WonderLLM识别对应的颜色，通过IIC协议将数据发送给ESP32主控板。

* #### 实现流程图

<img src="../_static/media/chapter_3/section_8/media/image2_1.png" style="width:5.76389in;height:1.10208in" alt="IMG_256" />



* #### **接线说明**

>[!note]
>
>**MicroPython代码可在任意支持MicroPython编程的主控上运行，为讲解方便，此处以我司ESP32核心板为例讲解说明。**

1)  接线时，WonderLLM的5V、GND、SCL和SDA引脚需与ESP32核心板进行连接，接线方式如下图所示：

<img src="../_static/media/chapter_2/section_2/media/image19.png" style="width:600px"  class="common_img" />


2)  ESP32核心板可与我司开源6路舵机控制器搭配使用，与WonderLLM的接线方式如下图：

<img src="../_static/media/chapter_2/section_2/media/image20.png" style="width:600px"  class="common_img" />


>[!note]
>
>**通电前确保不要有金属物体接触到主板，否则可能会因主板底部的引脚导致电路短路从而烧毁主板。**



* #### 程序下载

1. **ESP32程序下载**

>[!note]
>
>* **Micropython支持多种IDE下载，如Thoony、VScode（需安装相关插件），相关操作请用户自行检索，此处以我司“幻尔python编辑器”下载程序为例，可实现免安装使用，开箱即用。**
>* **如使用ESP32，在下载Micropython前，需确保ESP32中已烧录Micropython固件，相关固件下载请见Micropython官网。如使用我司ESP32核心板，也可直接烧录我司提供固件文件（路径：附录\10  ESP32核心板固件及烧录软件\02 ESP32固件烧录工具，烧录方式见同路径文档。**

1. 打开“**幻尔Python编辑器**”软件<img src="../_static/media/chapter_2/section_2/media/image1.png"  style="width:50px" />（路径：**附录\09  幻尔python编辑器**）；

2. 将本文档路径下的“**附录\05 ESP32程序文件\02 ESP32主控颜色识别例程\main.py**”文件，拖到幻尔Python编辑器中（需要拖到红框内区域才有效）；

   <img src="../_static/media/chapter_2/section_2/media/image2.png" style="width:600px"  class="common_img" />

3. 点击菜单栏的连接按钮<img src="../_static/media/chapter_2/section_2/media/image3.png" style="width:50px  " />，连接成功后会变为绿色的图标<img src="../_static/media/chapter_2/section_2/media/image4.png" style="width:50px"  />；

4. 连接成功后点击菜单栏上的下载按钮<img src="../_static/media/chapter_2/section_2/media/image5.png"  style="width:50px" />，将程序下载至ESP32内，等待下方信息交互方框内提示下载完成。

   <img src="..\_static\media\chapter_2\section_2/media/image6.png" style="width:600px"  class="common_img" />

>[!note]
>**完成以上4步后，请再将WonderLLM离线视觉功能通信库(“附录\05 ESP32程序文件\02 ESP32主控颜色识别例程\hw_esp32cam_ctl.py”)拖入，按照上述步骤说明重复操作将该库文件导入ESP32，下载完成后点击界面的复位图标<img src="../_static/media/chapter_3/section_8/media/image6_2.png"  style="width:50px" />即可使ESP32复位工作，输出信息会同步显示在下方输出信息栏。**



2. **WonderLLM颜色识别程序下载**

(1) 将Type-C数据线一端连接WonderLLM另一端连接电脑的USB接口。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image1.png" width="400px" />

(2) 打开本文档同路径下的**“附录\03 WonderLLM程序\ColorDetection\ColorDetection.ino”**程序文件。

<img src="..\_static\media/chapter_3/section_4/media/image2.png" style="width:600px"  class="common_img" />

(3) 接着选择“**ESP32S3 Dev Module**”开发板。

<img src="..\_static\media/chapter_3/section_3/media/image3.png" style="width:5.76458in;height:0.42292in" />

(4) 点击菜单栏的**“工具”**，按照下图选择相应的ESP32S3的开发板配置。

<img src="..\_static\media/chapter_3/section_3/media/image4.png" style="width:3.99653in;height:3.25069in"  />

(5) 最后点击<img src="..\_static\media/chapter_3/section_3/media/image5.png"  style="width:40px" />将代码下载至WonderLLM内，等待烧录完成即可。

<img src="..\_static\media/chapter_3/section_3/media/image3.png" style="width:5.76458in;height:0.42292in" />

<img src="..\_static\media/chapter_3/section_3/media/image6.png" style="width:5.76389in;height:0.52292in" />



* #### **实现效果**

1. 当WonderLLM识别到红色时，会在串口打印出**“COLOR_1”**。

   <img src="../_static/media/chapter_3/section_8/media/image13_1.png" style="width:600px"  class="common_img" />

2. 当WonderLLM识别到绿色，会在串口打印出**“COLOR_2”**；

<img src="../_static/media/chapter_3/section_8/media/image14_1.png" style="width:400px"  class="common_img" />



* #### 程序简要分析

1. **导入库文件**

(1) 导入IIC模块、WonderLLM离线视觉功能模块hw_esp32cam_ctl。

```python
from time import sleep_ms
from machine import Pin , I2C
from hw_esp32cam_ctl import HW_ESP32Cam 
```

(2) 定义红色、绿色在颜色识别功能中预设的ID，存放对模块预设所有颜色识别结果的数组`color_detect_result`，

```python
COLOR_red = 0
COLOR_green = 2

color_detect_result = [0] * 5
```



2. **初始化IIC**

(1) 初始化IIC总线，并将IIC总线句柄传入，将HW_ESP32Cam类实例化为对象cam。

```python
if __name__ == "__main__":
  iic = I2C(0, scl=Pin(23), sda=Pin(22), freq=100000)
  cam = HW_ESP32Cam(iic)
  sleep_ms(1000)
```



3. **循环调用子函数**

(1) 调用`colorDetect`函数获取模块实时对所有预设颜色的识别结果传入列表`color_detect_result`，并读取列表中红色、绿色对应ID的识别结果。若识别到则打印对应的标签。

```python
  while True:

    cam.colorDetect(color_detect_result)
    if (color_detect_result[COLOR_red] == COLOR_red):
        print("COLOR 1")
    if (color_detect_result[COLOR_green] == COLOR_green):
        print("COLOR 2")

    sleep_ms(600)
```



### 3.8.3 巡线识别例程

本节通过WonderLLM识别指定颜色的线段，通过IIC协议将数据发送给ESP32主控板。

* #### 实现流程图

<img src="../_static/media/chapter_3/section_7/media/image2_2.png" style="width:5.76389in;height:1.10208in" alt="IMG_256" />



* #### **接线说明**

>[!note]
>**MicroPython代码可在任意支持MicroPython编程的主控上运行，为讲解方便，此处以我司ESP32核心板为例讲解说明。**

1)  接线时，WonderLLM的5V、GND、SCL和SDA引脚需与ESP32核心板进行连接，接线方式如下图所示：

<img src="../_static/media/chapter_2/section_2/media/image19.png" style="width:600px"  class="common_img" />


2)  ESP32核心板可与我司开源6路舵机控制器搭配使用，与WonderLLM的接线方式如下图：

<img src="../_static/media/chapter_2/section_2/media/image20.png" style="width:600px"  class="common_img" />


>[!note]
>
>**通电前确保不要有金属物体接触到主板，否则可能会因主板底部的引脚导致电路短路从而烧毁主板。**



* #### 程序下载

1. **ESP32程序下载**

>[!note]
>
>* **Micropython支持多种IDE下载，如Thoony、VScode（需安装相关插件），相关操作请用户自行检索，此处以我司“幻尔python编辑器”下载程序为例，可实现免安装使用，开箱即用。**
>* **如使用ESP32，在下载Micropython前，需确保ESP32中已烧录Micropython固件，相关固件下载请见Micropython官网。如使用我司ESP32核心板，也可直接烧录我司提供固件文件（路径：附录\10  ESP32核心板固件及烧录软件\02 ESP32固件烧录工具，烧录方式见同路径文档。**

1. 打开“**幻尔Python编辑器**”软件<img src="../_static/media/chapter_2/section_2/media/image1.png"  style="width:50px" />（路径：**附录\09  幻尔python编辑器**）；

2. 将本文档路径下的“**附录\05 ESP32程序文件\03 ESP32主控巡线识别例程\main.py**”文件，拖到幻尔Python编辑器中（需要拖到红框内区域才有效）；

   <img src="../_static/media/chapter_2/section_2/media/image2.png" style="width:600px"  class="common_img" />

3. 点击菜单栏的连接按钮<img src="../_static/media/chapter_2/section_2/media/image3.png" style="width:50px  " />，连接成功后会变为绿色的图标<img src="../_static/media/chapter_2/section_2/media/image4.png" style="width:50px"  />；

4. 连接成功后点击菜单栏上的下载按钮<img src="../_static/media/chapter_2/section_2/media/image5.png"  style="width:50px" />，将程序下载至ESP32内，等待下方信息交互方框内提示下载完成。

   <img src="..\_static\media\chapter_2\section_2/media/image6.png" style="width:600px"  class="common_img" />
>[!note]
>**完成以上4步后，请再将WonderLLM离线视觉功能通信库(“附录\05 ESP32程序文件\03 ESP32主控巡线识别例程\hw_esp32cam_ctl.py”)拖入，按照上述步骤说明重复操作将该库文件导入ESP32，下载完成后点击界面的复位图标<img src="../_static/media/chapter_3/section_8/media/image6_2.png"  style="width:50px" />即可使ESP32复位工作，输出信息会同步显示在下方输出信息栏。**



2. **WonderLLM巡线识别程序下载**

(1) 使用Type-C线连接WonderLLM上方的Type-C接口。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image1.png" width="400px" />

(2) 打开程序**“附录\03 WonderLLM程序\LineTracking\LineTracking.ino”**。

<img class="common_img" src="..\_static\media/chapter_3/section_7/media/image11_2.png" />

(3) 选择**“ESP32S3 Dev Module”**开发板。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image3.png" />

(4) 点击菜单栏的**“工具”**，按照下图选择相应的ESP32S3的开发板配置。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image4.png" />

(5) 最后点击<img src="..\_static\media/chapter_3/section_4/media/image5.png" style="width:40px"/>将代码下载至WonderLLM内，等待烧录完成即可。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image3.png" />

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image6.png" />



* #### **实现效果**

当WonderLLM 识别到红色线段，会在串口打印出了上半部分、中半部分两个识别框的参数；(若未识别到，打印参数为全0)

<img src="../_static/media/chapter_3/section_8/media/image13_2.png" style="width:600px"  class="common_img" />



* #### 程序简要分析

1. **导入库文件**

(1) 导入IIC模块、WonderLLM离线视觉功能模块`hw_esp32cam_ctl`。

```python
from time import sleep_ms
from machine import Pin , I2C
from hw_esp32cam_ctl import HW_ESP32Cam 
```

(2) 定义红色在巡线识别功能中预设的ID、存放一种颜色线段两个识别框参数的列表`line_detect_result`。

```python
COLOR_red = 0

line_detect_result = [0] * 8
```



2. **初始化IIC**

初始化IIC总线，并将IIC总线句柄传入，将HW_ESP32Cam类实例化为对象cam。

```python
if __name__ == "__main__":
  iic = I2C(0, scl=Pin(23), sda=Pin(22), freq=100000)
  cam = HW_ESP32Cam(iic)
  sleep_ms(1000)
```



3. **循环调用子函数**

调用`line_position`读取红色线段2个巡线识别框参数，并打印在屏幕上。

```python
  while True:
    cam.line_position(COLOR_red,line_detect_result)
    print(f"Segment1: center_x:{line_detect_result[0]},  center_y:{line_detect_result[1]},  width:{line_detect_result[2]}, height:{line_detect_result[3]}\r\n")
    print(f"Segment2: center_x:{line_detect_result[4]},  center_y:{line_detect_result[5]},  width:{line_detect_result[6]}, height:{line_detect_result[7]}\r\n")
    sleep_ms(600)
```





### 3.8.4 幻尔python编辑器

>[!note]
>
>**如果出现编辑器打不开的情况，请将编辑器的名称更改为全英文，例如“Hiwonder”。**

* **功能介绍**

1. 我们将当前编辑器的界面分为了五部分，如下图所示：

<img src="../_static/media/chapter_2/section_2/media/image1_1.png" style="width:600px"  class="common_img" />

2. 每个区域都有相对应的功能，具体功能如下表所示：

<table border="1">
<tr><td>序号</td><td>区域名称</td><td>作用</td></tr>
<tr><td>1</td><td>菜单栏</td><td>包含文件、编辑、视图、连接、运行、帮助。</td></tr>
<tr><td>2</td><td>工具栏</td><td>包含了部分常用的快捷按键，与菜单栏部分按键的实现效果相同</td></tr>
<tr><td>3</td><td>文件列表</td><td>分为设备内和本地内的多个项目文件，可查看项目文件内容（文件夹、源代码等）。</td></tr>
<tr><td>4</td><td>代码编辑区</td><td>可以查看和编写代码。</td></tr>
<tr><td>5</td><td>终端</td><td>可查看消息日志与调试信息。当未连接设备时，仅可查看消息日志。</td></tr>
</table>



* **操作说明**

1. **导入本地项目**

(1) 初次导入本地项目时，左键单击**“本地项目”**即可弹出文件选择列表。（后续再次导入时，右击“**本地项目-\>切换项目路径**”即可）。

<img src="../_static/media/chapter_2/section_2/media/image2_1.png" style="width:600px"  class="common_img" />

(2) 选择存放MicroPython程序的路径，点击“**选择文件夹**”按钮。

<img src="../_static/media/chapter_2/section_2/media/image3_1.png" style="width:600px"  class="common_img" />

(3) 文件夹内的文件会自动添加至本地项目中，在“**本地项目**”处可看见。

<img src="../_static/media/chapter_2/section_2/media/image4_1.png" style="width:600px"  class="common_img" />

>[!note]
>**导入本地项目是将电脑文件导入至编辑器内，并非下载至ESP32核心板中。**

2. **查看导入的文件/程序**

这里我们双击文件列表内的程序文件查看详细代码，此处以“**march_on_the_spot.py**”为例：

<img src="../_static/media/chapter_2/section_2/media/image5_1.png" style="width:600px"  class="common_img" />

同理，将程序文件下载至ESP32核心板后，可在“**设备**”列表下双击查看程序文件。

3. **代码编写与储存**

界面右侧的代码编辑区支持代码创建、查看、编辑、修改、储存等功能。在开始编写代码前，需要阅读以下注意事项：

(1) 用户无法直接在“设备”标签内创建文件，且**“设备”**内的文件只能通过下载的方 式来保存修改内容。如需备份，可先复制至本地项目中。

(2) 请勿在编辑器内修改文件后缀为**“rob”**的动作组文件，以免引发未知的格式错误。 如需修改动作组文件，可在上位机内进行。

(3\) 提供的底层程序文件中，main.py 为设备的主程序，机器人上所有的功能都需通过该文件的启动来实现，即复位与开机操作都需要执行该程序，如果它处于卡死状态，后续的其他操作都无法进行。 因此，如果用户需要在该文件内部增加功能，保险起见，建议先修改程序名称。若将 main.py 命名为其它名字，即使调试程序时出现特殊卡死现象（快捷键**“Ctrl+C”**和**“Ctrl+D”**都失效），只需将控制板复位，删除并重新下载所需程序。

4. **程序下载与运行**

程序的下载是编辑器与设备之间的交互行为。此处以“**march_on_the_spot.py**”为例：

(1) 选择“**本地项目**”标签内的**“Hello.py”**文件后，点击工具栏的图标<img src="../_static/media/chapter_2/section_2/media/image6_1.png" style="width:50px" />，或直接右键该文件选择“**下载并运行**”

<img src="../_static/media/chapter_2/section_2/media/image7_1.png" style="width:600px"  class="common_img" />

(2) 可在终端界面中，查看下载进度及完成状态。上一步选择的是“**下载并运行**”，因此还可以查看程序的运行效果。

<img src="../_static/media/chapter_2/section_2/media/image8_1.png" style="width:600px"  class="common_img" />

(3) 下载完成后，程序会出现在“**设备**”标签下的文件列表内。

<img src="../_static/media/chapter_2/section_2/media/image9_1.png" style="width:600px"  class="common_img" />

(4) 最后将原先的**“main.py”**文件删除，将下载的“**change_speed.py**”重命名为“**main.py**”即可。

<img src="../_static/media/chapter_2/section_2/media/image10_1.png" style="width:600px"  class="common_img" />

(5)此外，还有几点需要用户知悉：

①除了这种下载方式之外，同样还可以先将需要下载的文件，提前更名为**“main.py”**再进行下载。

②“**下载并运行**”功能是先对设备进行复位，即重启，随后下载并运行程序，这样有利于程序运行的稳定性。

③如果无需立刻执行程序，可以点击按钮<img src="../_static/media/chapter_2/section_2/media/image11_1.png" style="width:40px" />，或右键目标文件选择“**下载**”即可。在后边需要执行程序前，我们可以先按<img src="../_static/media/chapter_2/section_2/media/image12_1.png" style="width:40px" />图标，进行设备复位再执行程序。

5. **终端使用方法（调试）**

(1) 终端是集信息窗口与调试界面于一体的功能区域。但需要说明的是，如果未连接设备，终端区域仅做信息查看作用，无法编辑和调试。

(2) 关于信息查看，在前面步骤中大家已经有所体验，因此不再细说。这里主要对调试方面的功能进行说明。

① 终端支持输入代码。在终端输入代码“print(123)”并按下回车，效果如下：

<img src="../_static/media/chapter_2/section_2/media/image13_1.png" style="width:600px"  class="common_img" />

② 此外，终端也支持自动缩进。在键入以冒号结尾的 python 语句（如 if、for、while），并按下回车键时，下一行将以 常规语句的相同缩进级别继续，或在适当情况下以其他缩进级别继续。如果按退格键，它将撤消一级缩进。

<img src="../_static/media/chapter_2/section_2/media/image14_1.png" style="width:600px"  class="common_img" />

③ 如需复制和粘贴代码，可在选中目标代码后，在终端界面处右键进行操作。

<img src="../_static/media/chapter_2/section_2/media/image15_1.png" style="width:200px"  class="common_img" />

>[!note]
>**需要注意的是，由于终端具备自动缩进的功能，粘贴代码前，需要按下“Ctrl+E”进入编辑模式，否则调试会出现缩进错误。**

④ 下图是采用正确方法进行复制粘贴的效果图，缩进格式正确。

<img src="../_static/media/chapter_2/section_2/media/image16_1.png" style="width:600px"  class="common_img" />

⑤ 下图为错误缩进格式：

<img src="../_static/media/chapter_2/section_2/media/image17_1.png" style="width:600px"  class="common_img" />

⑥ 如需退出编辑模式，可按**“Ctrl+C”**。此外，如果编写了一个死循环，也可按下“Ctrl+C”退出。

>[!note]
>
>* **在终端内，“Ctrl+C”快捷键只可用于中断已运行的程序，不具备复制功能，且“Ctrl+V”无粘贴作用。**
>* **在终端输入命令时，可以使用“Tab”键来补齐代码。例如，在终端处输入“os”后，按下“Tab”键，效果如下：**
>  **<img src="../_static/media/chapter_2/section_2/media/image18_1.png" style="width:600px"  class="common_img" />**
>   **如果当前代码可衔接的内容有两种或以上，终端处会列举出所有选项；如果只有一种，终端会自动补齐；如果没有，就无作用。**
>* **在终端处，可通过键盘的“↑”、“↓”键查看输入命令的历史记录，节省输入时间。关于更多命令以及命令说明，可前往<http://docs.micropython.org/en/latest/library/uos.html>进行查看。**


<p id = "anther2.2.4"></p>

### 3.8.5 ESP32核心板固件及烧录软件

* **设备连接**

将ESP32核心板Type-C接口通过USB线接入电脑，如下图。

<img src="../_static/media/chapter_2/section_2/media/image1_2.png" style="width:600px"  class="common_img" />



* **操作流程**

1. 请打开路径文件下"**附录\10  ESP32核心板固件及烧录软件\02 ESP32固件烧录工具**"目录下的**flash_download_tool_3.9.7.exe**文件。

   <img src="../_static/media/chapter_2/section_2/media/image2_2.png" style="width:600px"  class="common_img" />

2. 选择Chip Type为ESP32，其他保持默认，然后点击OK。

   <img src="../_static/media/chapter_2/section_2/media/image3_2.png" style="width:600px"  class="common_img" />

3. 工具打开后，点击“...”选择需要烧录的程序bin文件（存放路径：本文档下载链接文件下[03 ESP32核心板固件]()）。

   <img src="../_static/media/chapter_2/section_2/media/image4_2.png" style="width:600px"  class="common_img" />

   <img src="../_static/media/chapter_2/section_2/media/image5_2.png" style="width:600px"  class="common_img" />

4. 左侧需打勾，其余配置按照下图所示进行配置即可，COM端口号选择模块所占的端口号。

>[!note]
>**如果您按下图的配置，将SPI MODE设置为DIO，烧录固件后模块无法正常工作；请尝试将SPI MODE设置为DOUT并再次烧录。**

<img src="../_static/media/chapter_2/section_2/media/image6_2.png" style="width:600px"  class="common_img" />

5. 先点击"**ERASE**"擦除之前下载的固件(一定要进行)，等待状态栏显示“**FINISH完成**”。

   <img src="../_static/media/chapter_2/section_2/media/image7_2.png" style="width:600px"  class="common_img" />

   <img src="../_static/media/chapter_2/section_2/media/image8_2.png" style="width:600px"  class="common_img" />

6. 再点击"**START**"下载刚刚选择的固件，等待进度条加载完成，即完成固件下载。

<img src="../_static/media/chapter_2/section_2/media/image9_2.png" style="width:600px"  class="common_img" />

<img src="../_static/media/chapter_2/section_2/media/image10_2.png" style="width:600px"  class="common_img" />

7)  下载完成后，重新拔插数据线，设备重新上电后，即根据新固件程序开始工作。



## 3.9 与STM32主机通讯

### **3.9.1 人脸识别例程**

本节通过WonderLLM识别人脸，再通过IIC协议将数据发送给STM32主控板。

* **实现流程图**

<img src="../_static/media/chapter_3/section_8/media/image2.png" style="width:5.76389in;height:1.10208in" alt="IMG_256" />



* **传感器接线**

接线时，WonderLLM的5V、GND、SCL和SDA引脚需与STM32开发板(此处以我司开发板Ros Robot Controller v1.2为例)进行连接，接线方式如下图所示：

<img src="../_static/media/chapter_2/section_4/media/image14.png" style="width:600px"  class="common_img" />


>[!note]
>
>**通电前确保不要有金属物体接触到主板，否则可能会因主板底部的引脚导致电路短路从而烧毁主板。**



* **程序下载**

1. **STM32程序烧录**

(1) 使用Type-C线插入stm32主控板的type-c口(只能插在UART1接口，如下图所示)，并且与电脑的USB口连接：

<img src="../_static/media/chapter_2/section_4/media/image1.png" style="width:600px"  class="common_img" />

(2) 打开电脑设备管理器，在端口中查看串口号：

<img src="../_static/media/chapter_2/section_4/media/image2.png" style="width:600px"  class="common_img" />

(3) 打开**ATX-XISP**软件，选择对应串口号，并且选择波特率为115200：

<img src="../_static/media/chapter_2/section_4/media/image3.png" style="width:600px"  class="common_img" />

(4) 按照下图进行配置：

<img src="../_static/media/chapter_2/section_4/media/image4.png" style="width:600px"  class="common_img" />

(5) 在软件界面点击“**文件**”按钮，选择“**附录\06 STM32程序文件\01 STM32主控人脸识别例程\RosRobotControllerM4-armclang\MDK-ARM\RosRobotControllerM4\RosRobotControllerM4.hex**”文件进行烧录:

<img src="../_static/media/chapter_2/section_4/media/image5.png" style="width:600px"  class="common_img" />

(6) 在页面中点击**“开始编程”**按钮，将生成好的hex文件烧录到stm32主控板上，等待烧录成功即可。

<img src="..\_static\media\chapter_2\section_4\media/image6.png" style="width:600px"  class="common_img" />



2. **WonderLLM人脸识别程序下载**

(1) 将Type-C数据线一端连接WonderLLM另一端连接电脑的USB接口。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image1.png" width="400px" />

(2) 打开本文档同路径下的“**附录\03 WonderLLM程序\FaceDetection\FaceDetection.ino**”程序文件。

<img src="..\_static\media/chapter_3/section_3/media/image2.png" style="width:5.76458in;height:2.37431in" />

(3) 接着选择“**ESP32S3 Dev Module**”开发板。

<img src="..\_static\media/chapter_3/section_3/media/image3.png" style="width:5.76458in;height:0.42292in" />

(4) 点击菜单栏的**“工具”**，按照下图选择相应的ESP32S3的开发板配置。

<img src="..\_static\media/chapter_3/section_3/media/image4.png" style="width:3.99653in;height:3.25069in"  />

(5) 最后点击<img src="..\_static\media/chapter_3/section_3/media/image5.png"  style="width:40px" />将代码下载至WonderLLM内，等待烧录完成即可。

<img src="..\_static\media/chapter_3/section_3/media/image3.png" style="width:5.76458in;height:0.42292in" />

<img src="..\_static\media/chapter_3/section_3/media/image6.png" style="width:5.76389in;height:0.52292in" />



* **实现效果**

当WonderLLM识别到人脸时，主控会在串口3打印出**“find face”**，波特率为115200。

<img src="../_static/media/chapter_3/section_9/media/image19_1.png"  style="width:600px"  class="common_img" />



* **程序简要分析**

>[!note]
>
>**WonderLLM模块STM32例程运行FreeRTOS系统，开放app_task任务供用户执行自定义逻辑，main.c仅用于初始化系统外设及开启RTOS系统，我们将调用WonderLLM模块有关的逻辑放置于app_task任务回调函数app_task_entry（位于app.c）内。**

1. **定义WonderLLM的地址**

`device_addr`为设备地址，`face_data_reg_addr`为寄存器地址。其中寄存器会返回4个元素。

```c
#define device_addr 0x52  //（设备地址）	ESP32-Cam的通讯地址

//当ESP32-Cam为人脸识别功能时：
#define face_data_reg_addr   0x01  //（人脸识别寄存器起始地址）
/*寄存器内元素排布如下：
		 data[0] : center_x
		 data[1] : center_y
		 data[2] : detection_width
		 data[3] : detection_length
*/
```

2. **初始化IIC**

```c
void MX_I2C2_Init(void)
{

  /* USER CODE BEGIN I2C2_Init 0 */

  /* USER CODE END I2C2_Init 0 */

  /* USER CODE BEGIN I2C2_Init 1 */

  /* USER CODE END I2C2_Init 1 */
  hi2c2.Instance = I2C2;
  hi2c2.Init.ClockSpeed = 100000;
  hi2c2.Init.DutyCycle = I2C_DUTYCYCLE_16_9;
  hi2c2.Init.OwnAddress1 = 0;
  hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c2.Init.OwnAddress2 = 0;
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c2) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN I2C2_Init 2 */

  /* USER CODE END I2C2_Init 2 */

}
```

3. **循环调用子函数**

若识别到人脸时，则在串口3打印**“find face”**，并清除数据。

```c
/*
功能：获取模块人脸识别数据，并串口打印
参数：无
注意：1.请确保模块已烧录对应的人脸识别固件，否则模块将没有有效数据供读取
      2.在调用本函数前，已调用MX_I2C2_Init()完成硬件功能初始化
*/
void esp32cam_face_data_get(){
	HAL_I2C_Mem_Read(&hi2c2, device_addr << 1 , face_data_reg_addr, I2C_MEMADD_SIZE_8BIT, cam1.face_detection ,4*sizeof(uint8_t), 0xFFFF);
	/*IIC8位地址中，高7位为设备地址位，最低位为读写指示位（1为读，0为写），这就是使用device_addr << 1将设备地址左移一位的意义，具体读写位的填写由HAL_I2C_Mem_Read、HAL_I2C_Mem_Write内部实现*/
	if(cam1.face_detection[0] != 0 && cam1.face_detection[1] != 0 && cam1.face_detection[2] != 0  && cam1.face_detection[3] != 0){
		const char *msg = "find face\n";
		HAL_UART_Transmit_DMA(&huart3, (uint8_t*)msg, strlen(msg));  /* 触发 DMA 发送*/
	}
}
```



### 3.9.2 颜色识别例程

本节通过WonderLLM识别对应的颜色，通过IIC协议将数据发送给STM32主控板。

* **实现流程图**

<img src="../_static/media/chapter_3/section_8/media/image2_1.png" style="width:5.76181in;height:1.10139in" alt="企业微信截图_17134509134326" />



* **传感器接线**

接线时，WonderLLM的5V、GND、SCL和SDA引脚需与STM32开发板(此处以我司开发板Ros Robot Controller v1.2为例)进行连接，接线方式如下图所示：

<img src="../_static/media/chapter_2/section_4/media/image14.png" style="width:600px"  class="common_img" />



* **程序下载**

1. **STM32程序烧录**

(1) 使用Type-C线插入stm32主控板的type-c口(只能插在UART1接口，如下图所示)，并且与电脑的USB口连接：

<img src="../_static/media/chapter_2/section_4/media/image1.png" style="width:600px"  class="common_img" />

(2) 打开电脑设备管理器，在端口中查看串口号：

<img src="../_static/media/chapter_2/section_4/media/image2.png" style="width:600px"  class="common_img" />

(3) 打开**ATX-XISP**软件，选择对应串口号，并且选择波特率为115200：

<img src="../_static/media/chapter_2/section_4/media/image3.png" style="width:600px"  class="common_img" />

(4) 按照下图进行配置：

<img src="../_static/media/chapter_2/section_4/media/image4.png" style="width:600px"  class="common_img" />

(5) 在软件界面点击“**文件**”按钮，选择“**附录\06 STM32程序文件\02 STM32主控颜色识别例程\RosRobotControllerM4-armclang\MDK-ARM\RosRobotControllerM4\RosRobotControllerM4.hex**”文件进行烧录:

<img src="../_static/media/chapter_2/section_4/media/image5.png" style="width:600px"  class="common_img" />

(6) 在页面中点击**“开始编程”**按钮，将生成好的hex文件烧录到stm32主控板上，等待烧录成功即可。

<img src="..\_static\media\chapter_2\section_4\media/image6.png" style="width:600px"  class="common_img" />



2. **WonderLLM颜色识别程序下载**

(1) 使用Type-C线连接WonderLLM上方的Type-C接口。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image1.png" width="400px" />

(2) 打开程序**“附录\03 WonderLLM程序\ColorDetection\ColorDetection.ino”**。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image2.png" />

(3) 选择**“ESP32S3 Dev Module”**开发板。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image3.png" />

(4) 点击菜单栏的**“工具”**，按照下图选择相应的ESP32S3的开发板配置。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image4.png" />

(5) 最后点击<img src="..\_static\media/chapter_3/section_4/media/image5.png" style="width:40px"/>将代码下载至WonderLLM内，等待烧录完成即可。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image3.png" />

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image6.png" />



* #### 实现效果

1. 当WonderLLM识别到红色，主控会在串口打印出**“COLOR_1”**；

   <img src="../_static/media/chapter_3/section_9/media/image19.png" style="width:600px"  class="common_img" />

2. 当WonderLLM识别到绿色，主控会在串口打印出**“COLOR_2”**。

   <img src="../_static/media/chapter_3/section_9/media/image20.png" style="width:600px"  class="common_img"/>

   

* #### 程序简要分析

>[!note]
>
>**WonderLLM模块STM32例程运行FreeRTOS系统，开放app_task任务供用户执行自定义逻辑，main.c仅用于初始化系统外设及开启RTOS系统，我们将调用WonderLLM模块有关的逻辑放置于app_task任务回调函数app_task_entry（位于app.c）内。**

1. **定义WonderLLM的地址**

(1) `device_addr`为设备地址，`color_data_reg_addr`为寄存器地址。其中寄存器会返回4个元素ID。

```c
#define device_addr 0x52  //（设备地址）	ESP32-Cam的通讯地址
```

```c
//当ESP32-Cam为颜色识别功能时：
#define color_data_reg_addr 0x00	//（颜色寄存器起始地址，一直到0x04，颜色顺序：红黄绿蓝紫，0x04为显示所有识别到的颜色ID）
/*前4个元素，每个元素的信息排布如下：                        
	   data[0] : center_x												  
		 data[1] : center_y                    
		 data[2] : width                        
		 data[3] : length                       
```

2. **初始化IIC**

```c
void MX_I2C2_Init(void)
{

  /* USER CODE BEGIN I2C2_Init 0 */

  /* USER CODE END I2C2_Init 0 */

  /* USER CODE BEGIN I2C2_Init 1 */

  /* USER CODE END I2C2_Init 1 */
  hi2c2.Instance = I2C2;
  hi2c2.Init.ClockSpeed = 100000;
  hi2c2.Init.DutyCycle = I2C_DUTYCYCLE_16_9;
  hi2c2.Init.OwnAddress1 = 0;
  hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c2.Init.OwnAddress2 = 0;
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c2) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN I2C2_Init 2 */

  /* USER CODE END I2C2_Init 2 */

}
```

3. **循环调用子函数**

读取存放所有颜色的寄存器地址，判断若返回值全为0时，则未识别到颜色；若有返回值不为0时，则表明识别到了对应的颜色，则打印对应的字符串。

```c
/*
功能：获取模块颜色识别数据，并串口打印
参数：无
注意：1.请确保模块已烧录对应的颜色识别固件，否则模块将没有有效数据供读取
      2.在调用本函数前，已调用MX_I2C2_Init()完成硬件功能初始化
*/
void esp32cam_color_data_get(uint8_t reg){
	HAL_I2C_Mem_Read(&hi2c2, device_addr << 1, reg, I2C_MEMADD_SIZE_8BIT, cam1.color_detection, 4*sizeof(uint8_t), 0xFFFF);
	if(reg == 0x04){
		if(cam1.color_detection[0] != 0){
			const char *msg = "COLOR 1\n";
			HAL_UART_Transmit_DMA(&huart3, (uint8_t*)msg, strlen(msg));  /* 触发 DMA 发送*/
		}
		if(cam1.color_detection[1] != 0){
			const char *msg = "COLOR 2\n";
			HAL_UART_Transmit_DMA(&huart3, (uint8_t*)msg, strlen(msg));  /* 触发 DMA 发送*/
		}
		if(cam1.color_detection[2] != 0){
			const char *msg = "COLOR 3\n";
			HAL_UART_Transmit_DMA(&huart3, (uint8_t*)msg, strlen(msg));  /* 触发 DMA 发送*/
		}
		if(cam1.color_detection[3] != 0){
			const char *msg = "COLOR 4\n";
			HAL_UART_Transmit_DMA(&huart3, (uint8_t*)msg, strlen(msg));  /* 触发 DMA 发送*/
		}
	}else{
		HAL_UART_Transmit_DMA(&huart3, cam1.color_detection, 4);  /* 触发 DMA 发送*/
	}
	
}
```



### 3.9.3 巡线识别例程

本节通过WonderLLM识别指定颜色的线段，通过IIC协议将数据发送给STM32主控板。

* **实现流程图**

<img src="../_static/media/chapter_3/section_7/media/image2_2.png" style="width:5.76181in;height:1.10139in" alt="企业微信截图_17134509134326" />



* **传感器接线**

接线时，WonderLLM的5V、GND、SCL和SDA引脚需与STM32开发板(此处以我司开发板Ros Robot Controller v1.2为例)进行连接，接线方式如下图所示：

<img src="../_static/media/chapter_2/section_4/media/image14.png" style="width:600px"  class="common_img" />



* **程序下载**

1. **STM32程序烧录**

(1) 使用Type-C线插入stm32主控板的type-c口(只能插在UART1接口，如下图所示)，并且与电脑的USB口连接：

<img src="../_static/media/chapter_2/section_4/media/image1.png" style="width:600px"  class="common_img" />

(2) 打开电脑设备管理器，在端口中查看串口号：

<img src="../_static/media/chapter_2/section_4/media/image2.png" style="width:600px"  class="common_img" />

(3) 打开**ATX-XISP**软件，选择对应串口号，并且选择波特率为115200：

<img src="../_static/media/chapter_2/section_4/media/image3.png" style="width:600px"  class="common_img" />

(4) 按照下图进行配置：

<img src="../_static/media/chapter_2/section_4/media/image4.png" style="width:600px"  class="common_img" />

(5) 在软件界面点击“**文件**”按钮，选择“**附录\06 STM32程序文件\03 STM32主控巡线识别例程\RosRobotControllerM4-armclang\MDK-ARM\RosRobotControllerM4\RosRobotControllerM4.hex**”文件进行烧录:

<img src="../_static/media/chapter_2/section_4/media/image5.png" style="width:600px"  class="common_img" />

(6) 在页面中点击**“开始编程”**按钮，将生成好的hex文件烧录到stm32主控板上，等待烧录成功即可。

<img src="..\_static\media\chapter_2\section_4\media/image6.png" style="width:600px"  class="common_img" />



2. **WonderLLM巡线识别程序下载**

(1) 使用Type-C线连接WonderLLM上方的Type-C接口。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image1.png" width="400px" />

(2) 打开程序**“附录\03 WonderLLM程序\LineTracking\LineTracking.ino”**。

<img class="common_img" src="..\_static\media/chapter_3/section_7/media/image11_2.png" />

(3) 选择**“ESP32S3 Dev Module”**开发板。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image3.png" />

(4) 点击菜单栏的**“工具”**，按照下图选择相应的ESP32S3的开发板配置。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image4.png" />

(5) 最后点击<img src="..\_static\media/chapter_3/section_4/media/image5.png" style="width:40px"/>将代码下载至WonderLLM内，等待烧录完成即可。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image3.png" />

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image6.png" />



* #### 实现效果

1. 当WonderLLM识别到红色，主控会在串口打印出**“COLOR_1”**；

   <img src="../_static/media/chapter_3/section_9/media/image19.png" style="width:600px"  class="common_img" />

2. 当WonderLLM识别到绿色，主控会在串口打印出**“COLOR_2”**。

   <img src="../_static/media/chapter_3/section_9/media/image20.png" style="width:600px"  class="common_img"/>

   

* #### 程序简要分析

>[!note]
>
>**WonderLLM模块STM32例程运行FreeRTOS系统，开放app_task任务供用户执行自定义逻辑，main.c仅用于初始化系统外设及开启RTOS系统，我们将调用WonderLLM模块有关的逻辑放置于app_task任务回调函数app_task_entry（位于app.c）内。**

1. **定义WonderLLM的地址**

(1) `device_addr`为设备地址，`color_data_reg_addr`为寄存器地址。其中寄存器会返回4个元素ID。

```c
#define device_addr 0x52  //（设备地址）	ESP32-Cam的通讯地址
```

```c
//当ESP32-Cam为颜色识别功能时：
#define color_data_reg_addr 0x00	//（颜色寄存器起始地址，一直到0x04，颜色顺序：红绿蓝紫，0x04为显示所有识别到的颜色ID）
/*前4个元素，每个元素的信息排布如下：         最后一个元素内，信息排布如下:                
	   data[0] : center_x												  data[0] : 红色ID	
		 data[1] : center_y                         data[1] : 绿色ID
		 data[2] : width                            data[2] : 蓝色ID
		 data[3] : length                           data[3] : 紫色ID
```

2. **初始化IIC**

```c
void MX_I2C2_Init(void)
{

  /* USER CODE BEGIN I2C2_Init 0 */

  /* USER CODE END I2C2_Init 0 */

  /* USER CODE BEGIN I2C2_Init 1 */

  /* USER CODE END I2C2_Init 1 */
  hi2c2.Instance = I2C2;
  hi2c2.Init.ClockSpeed = 100000;
  hi2c2.Init.DutyCycle = I2C_DUTYCYCLE_16_9;
  hi2c2.Init.OwnAddress1 = 0;
  hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c2.Init.OwnAddress2 = 0;
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c2) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN I2C2_Init 2 */

  /* USER CODE END I2C2_Init 2 */

}
```

3. **循环调用子函数**

读取存放所有颜色的寄存器地址，判断若返回值全为0时，则未识别到颜色；若有返回值不为0时，则表明识别到了对应的颜色，则打印对应的字符串。

```c
/*
功能：获取模块颜色识别数据，并串口打印
参数：无
注意：1.请确保模块已烧录对应的颜色识别固件，否则模块将没有有效数据供读取
      2.在调用本函数前，已调用MX_I2C2_Init()完成硬件功能初始化
*/
void esp32cam_color_data_get(uint8_t reg){
	HAL_I2C_Mem_Read(&hi2c2, device_addr << 1, reg, I2C_MEMADD_SIZE_8BIT, cam1.color_detection, 4*sizeof(uint8_t), 0xFFFF);
	if(reg == 0x04){
		if(cam1.color_detection[0] != 0){
			const char *msg = "COLOR 1\n";
			HAL_UART_Transmit_DMA(&huart3, (uint8_t*)msg, strlen(msg));  /* 触发 DMA 发送*/
		}
		if(cam1.color_detection[1] != 0){
			const char *msg = "COLOR 2\n";
			HAL_UART_Transmit_DMA(&huart3, (uint8_t*)msg, strlen(msg));  /* 触发 DMA 发送*/
		}
		if(cam1.color_detection[2] != 0){
			const char *msg = "COLOR 3\n";
			HAL_UART_Transmit_DMA(&huart3, (uint8_t*)msg, strlen(msg));  /* 触发 DMA 发送*/
		}
		if(cam1.color_detection[3] != 0){
			const char *msg = "COLOR 4\n";
			HAL_UART_Transmit_DMA(&huart3, (uint8_t*)msg, strlen(msg));  /* 触发 DMA 发送*/
		}
	}else{
		HAL_UART_Transmit_DMA(&huart3, cam1.color_detection, 4);  /* 触发 DMA 发送*/
	}
	
}
```



## 3.10 与树莓派主机通讯

### 3.10.1 人脸识别例程

本节通过WonderLLM识别人脸，再通过IIC协议将数据发送给树莓派主控。

* **实现流程图**

<img src="../_static/media/chapter_3/section_8/media/image2.png" style="width:600px"  class="common_img" />



* **传感器接线**

WonderLLM模块与树莓派主控板的连接如下图所示：

<img src="../_static/media/chapter_3/section_10/media/image4.png" style="width:600px"  class="common_img" />

* #### 程序下载

1. **树莓派程序导入**

(1) 首先打开树莓派，并使用您的PC主机通过VNC等方式连接到树莓派。

(2) 将该文档同路径下**“附录\07 树莓派程序文件\01 树莓派人脸识别例程”**的示例文件通过SSH等方式上传到树莓派任意路径。

<img src="../_static/media/chapter_3/section_10/media/image5.jpeg" style="width:600px"  class="common_img" />

(3) 菜单栏点击：**"TOOLS"--"Open Current Folder in Terminal"**，在当前路径打开命令行。

<img src="../_static/media/chapter_3/section_10/media/image6.jpeg" style="width:600px"  class="common_img" />

(4) 命令行输入如下指令即可运行程序：

```bash
python main.py
```

<img src="../_static/media/chapter_3/section_10/media/image7.jpeg" style="width:600px"  class="common_img" />



2. **WonderLLM人脸识别程序下载**

(1) 将Type-C数据线一端连接WonderLLM另一端连接电脑的USB接口。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image1.png" width="400px" />

(2) 打开本文档同路径下的“**附录\03 WonderLLM程序\FaceDetection\FaceDetection.ino**”程序文件。

<img src="..\_static\media/chapter_3/section_3/media/image2.png" style="width:5.76458in;height:2.37431in" />

(3) 接着选择“**ESP32S3 Dev Module**”开发板。

<img src="..\_static\media/chapter_3/section_3/media/image3.png" style="width:5.76458in;height:0.42292in" />

(4) 点击菜单栏的**“工具”**，按照下图选择相应的ESP32S3的开发板配置。

<img src="..\_static\media/chapter_3/section_3/media/image4.png" style="width:3.99653in;height:3.25069in"  />

(5) 最后点击<img src="..\_static\media/chapter_3/section_3/media/image5.png"  style="width:40px" />将代码下载至WonderLLM内，等待烧录完成即可。

<img src="..\_static\media/chapter_3/section_3/media/image3.png" style="width:5.76458in;height:0.42292in" />

<img src="..\_static\media/chapter_3/section_3/media/image6.png" style="width:5.76389in;height:0.52292in" />



* **实现效果**

当WonderLLM识别到人脸时，会在命令行打印出“find face”。

<img src="../_static/media/chapter_3/section_10/media/image13_1.png" style="width:3.46875in;height:0.20833in" />



* **程序简要分析**

1. **定义WonderLLM的地址**

`device_addr`为设备地址，`face_data_reg_addr`为寄存器地址。其中寄存器会返回4个元素。

```python
ESP32CAM_ADDR = 0x52

#当ESP32-Cam为人脸识别功能时：
'''
     data[0] : center_x
		 data[1] : center_y
		 data[2] : detection_width
		 data[3] : detection_length
'''
face_data_reg_addr = 0x01  #（人脸识别寄存器地址）
```

2. **初始化IIC**

```python
bus = smbus.SMBus(I2C_BUS)
```

3. **循环调用子函数**

若识别到人脸时，打印**“find face”**。

```python
if __name__ == "__main__":
  while True:
    #获取人脸数据
    result = faceDetect()
    if (result == true):
	  print("find face")
	  
    time.sleep(2)
```



### **3.10.2 颜色识别例程**

本节通过WonderLLM识别对应的颜色，通过IIC协议将数据发送给树莓派主控板。

* **实现流程图**

<img src="../_static/media/chapter_3/section_9/media/image2.png" style="width:5.76181in;height:1.10139in" alt="企业微信截图_17134509134326" />



* **传感器接线**

WonderLLM模块与树莓派主控板的连接如下图所示：

<img src="../_static/media/chapter_3/section_10/media/image4.png" style="width:600px"  class="common_img" />





* #### 程序下载

1. **树莓派程序导入**

(1) 首先打开树莓派，并使用您的PC主机通过VNC等方式连接到树莓派。

(2) 将该文档同路径下**“附录\07 树莓派程序文件\02 树莓派颜色识别例程”**的示例文件通过SSH等方式上传到树莓派任意路径。

<img src="../_static/media/chapter_3/section_10/media/image5.jpeg" style="width:600px"  class="common_img" />

(3) 菜单栏点击：**"TOOLS"--"Open Current Folder in Terminal"**，在当前路径打开命令行。

<img src="../_static/media/chapter_3/section_10/media/image6.jpeg" style="width:600px"  class="common_img" />

(4) 命令行输入如下指令即可运行程序：

```bash
python main.py
```

<img src="../_static/media/chapter_3/section_10/media/image7.jpeg" style="width:600px"  class="common_img" />



2. **WonderLLM颜色识别程序下载**

(1) 将Type-C数据线一端连接WonderLLM另一端连接电脑的USB接口。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image1.png" width="400px" />

(2) 打开本文档同路径下的“**附录\03 WonderLLM程序\ColorDetection\ColorDetection.ino**”程序文件。

<img src="..\_static\media/chapter_3/section_4/media/image2.png" style="width:600px"  class="common_img" />

(3) 接着选择“**ESP32S3 Dev Module**”开发板。

<img src="..\_static\media/chapter_3/section_3/media/image3.png" style="width:5.76458in;height:0.42292in" />

(4) 点击菜单栏的**“工具”**，按照下图选择相应的ESP32S3的开发板配置。

<img src="..\_static\media/chapter_3/section_3/media/image4.png" style="width:3.99653in;height:3.25069in"  />

(5) 最后点击<img src="..\_static\media/chapter_3/section_3/media/image5.png"  style="width:40px" />将代码下载至WonderLLM内，等待烧录完成即可。

<img src="..\_static\media/chapter_3/section_3/media/image3.png" style="width:5.76458in;height:0.42292in" />

<img src="..\_static\media/chapter_3/section_3/media/image6.png" style="width:5.76389in;height:0.52292in" />



* **实现效果**

1. 当WonderLLM 识别到红色，会在串口打印出**“COLOR_1”**；

   <img src="../_static/media/chapter_3/section_10/media/image13.png" style="width:4.22917in;height:0.20833in" />

2. 当WonderLLM 识别到绿色，会在串口打印出**“COLOR_2”**。

   <img src="../_static/media/chapter_3/section_10/media/image14.png" style="width:4.25139in;height:0.2in" />



* **程序简要分析**

1. **定义WonderLLM的地址**

`device_addr`为设备地址，`Color0_Detect_Reg`开始为颜色识别寄存器地址。其中寄存器会返回4个元素ID。

```python
ESP32CAM_ADDR = 0x52
```

```python
#当ESP32-Cam为颜色识别功能时：
#（颜色寄存器起始地址，一直到0x04，颜色顺序：红黄绿蓝紫）
'''
    前4个元素，每个元素的信息排布如下：            
	  data[0] : center_x												  
		data[1] : center_y                       
		data[2] : width                            
		data[3] : length                          
'''
Color_num = 5

Color0_Detect_Reg = 0x00   #ID 0对应颜色默认红色
Color1_Detect_Reg = 0x01   #ID 1对应颜色默认黄色
Color2_Detect_Reg = 0x02   #ID 2对应颜色默认绿色
Color3_Detect_Reg = 0x03   #ID 3对应颜色默认蓝色
Color4_Detect_Reg = 0x04   #ID 4对应颜色默认紫色
```

2. **初始化IIC**

```python
bus = smbus.SMBus(I2C_BUS)
```

3. **循环调用子函数**

读取存放所有颜色的寄存器地址，判断若返回列表color_detect_result全为0时，则未识别到颜色；若列表某元素取值为对应颜色的ID时，则表明识别到了对应的颜色，则打印对应的字符串(在例程中我们只处理对红、绿两种颜色的识别结果)。

```python
if __name__ == "__main__":

	COLOR_red = 0
	COLOR_green = 2
	
	color_detect_result = [0] * 5

  while True:
    #获取颜色识别数据
    colorDetect(color_detect_result)
    if (color_detect_result[COLOR_red] == COLOR_red):
        print("COLOR 1")
    if (color_detect_result[COLOR_green] == COLOR_green):
        print("COLOR 2")
    
    time.sleep(2)
```



### **3.10.3 巡线识别例程**

本节通过WonderLLM识别指定颜色的线段，通过IIC协议将数据发送给树莓派主控板。

* **实现流程图**

<img src="../_static/media/chapter_3/section_7/media/image2_2.png" style="width:5.76181in;height:1.10139in" alt="企业微信截图_17134509134326" />



* **传感器接线**

WonderLLM模块与树莓派主控板的连接如下图所示：

<img src="../_static/media/chapter_3/section_10/media/image4.png" style="width:600px"  class="common_img" />



* #### 程序下载

1. **树莓派程序导入**

(1) 首先打开树莓派，并使用您的PC主机通过VNC等方式连接到树莓派。

(2) 将该文档同路径下**“附录\07 树莓派程序文件\03 树莓派巡线识别例程”**的示例文件通过SSH等方式上传到树莓派任意路径。

<img src="../_static/media/chapter_3/section_10/media/image5.jpeg" style="width:600px"  class="common_img" />

(3) 菜单栏点击：**"TOOLS"--"Open Current Folder in Terminal"**，在当前路径打开命令行。

<img src="../_static/media/chapter_3/section_10/media/image6.jpeg" style="width:600px"  class="common_img" />

(4) 命令行输入如下指令即可运行程序：

```bash
python main.py
```

<img src="../_static/media/chapter_3/section_10/media/image7.jpeg" style="width:600px"  class="common_img" />



2. **WonderLLM巡线识别程序下载**

(1) 使用Type-C线连接WonderLLM上方的Type-C接口。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image1.png" width="400px" />

(2) 打开程序**“附录\03 WonderLLM程序\LineTracking\LineTracking.ino”**。

<img class="common_img" src="..\_static\media/chapter_3/section_7/media/image11_2.png" />

(3) 选择**“ESP32S3 Dev Module”**开发板。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image3.png" />

(4) 点击菜单栏的**“工具”**，按照下图选择相应的ESP32S3的开发板配置。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image4.png" />

(5) 最后点击<img src="..\_static\media/chapter_3/section_4/media/image5.png" style="width:40px"/>将代码下载至WonderLLM内，等待烧录完成即可。

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image3.png" />

<img class="common_img" src="..\_static\media/chapter_3/section_4/media/image6.png" />



* #### **实现效果**

当WonderLLM 识别到红色线段，会在串口打印出了上半部分、中半部分两个识别框的参数；(若未识别到，打印参数为全0)

<img src="../_static/media/chapter_3/section_10/media/image19.png" style="width:600px"  class="common_img" />



* #### 程序简要分析

1. **定义WonderLLM的地址**

`device_addr`为设备地址，`Color0_segment1_Detect_Reg`开始为巡线识别寄存器地址。其中寄存器会返回4个元素ID。

```python
ESP32CAM_ADDR = 0x52
```

```python
#当ESP32-Cam为巡线识别功能时：
#（视觉巡线寄存器起始地址，一直到0xA7，颜色顺序：红绿蓝紫，A0、A1分别为红色的上下两部分，之后以此类推）
'''
     data[0]:center_x                  
     data[1]:center_y           
     data[2]:detection_width           
     data[3]:detection_length                        
'''
Color_line_num = 4

Color0_segment1_Detect_Reg = 0xA0    #ID 0对应颜色默认红色
Color0_segment2_Detect_Reg = 0xA1    #ID 0对应颜色默认红色

Color1_segment1_Detect_Reg = 0xA2    #ID 1对应颜色默认绿色
Color1_segment2_Detect_Reg = 0xA3    #ID 1对应颜色默认绿色

Color2_segment1_Detect_Reg = 0xA4    #ID 2对应颜色默认蓝色
Color2_segment2_Detect_Reg = 0xA5    #ID 2对应颜色默认蓝色

Color3_segment1_Detect_Reg = 0xA6    #ID 3对应颜色默认紫色
Color3_segment2_Detect_Reg = 0xA7    #ID 3对应颜色默认紫色
```

(2) 定义红色在巡线识别功能中预设的ID、存放一种颜色线段两个识别框参数的列表`line_detect_result`。

```python
if __name__ == "__main__":
  COLOR_red = 0
  line_detect_result = [0] * 8
```

2. **初始化IIC**

```python
bus = smbus.SMBus(I2C_BUS)
```

3. **循环调用子函数**

调用`line_position`读取红色线段2个巡线识别框参数，并打印在屏幕上。

```python
  while True:

    line_position(COLOR_red,line_detect_result)
    print(f"Segment1: center_x:{line_detect_result[0]},  center_y:{line_detect_result[1]},  width:{line_detect_result[2]}, height:{line_detect_result[3]}\r\n")
    print(f"Segment2: center_x:{line_detect_result[4]},  center_y:{line_detect_result[5]},  width:{line_detect_result[6]}, height:{line_detect_result[7]}\r\n")
    
    time.sleep(2)
```



